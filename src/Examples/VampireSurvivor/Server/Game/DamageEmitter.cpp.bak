#include "Entity/Monster.h"
#include "Entity/ProjectileFactory.h"
#include "Game/GameConfig.h"
#include "Game/Room.h"

namespace SimpleGame {

DamageEmitter::DamageEmitter(int32_t skillId, std::shared_ptr<Player> owner) : _skillId(skillId), _owner(owner)
{
    const auto *tmpl = DataManager::Instance().GetSkillTemplate(skillId);
    if (tmpl)
    {
        _damage = tmpl->damage;
        _typeId = tmpl->typeId;
        _tickInterval = tmpl->tickInterval;
        _hitRadius = tmpl->hitRadius;
        _emitterType = tmpl->emitterType;
        _pierce = tmpl->pierce;
        _maxTargetsPerTick = tmpl->maxTargetsPerTick;
        _targetRule = tmpl->targetRule;
        _lifeTime = tmpl->lifeTime;
    }
    // Start ready to fire
    _timer = _tickInterval;
}

void DamageEmitter::Update(float dt, Room *room)
{
    auto owner = _owner.lock();
    if (!owner || owner->IsDead() || !room || !_active)
        return;

    _elapsedTime += dt;
    if (_lifeTime > 0.0f && _elapsedTime >= _lifeTime)
    {
        _active = false;
        return;
    }

    _timer += dt;
    if (_timer >= _tickInterval)
    {
        _timer -= _tickInterval;

        float px = owner->GetX();
        float py = owner->GetY();

        if (_emitterType == "Linear")
        {
            Vector2 forward = owner->GetFacingDirection();
            float speed = 15.0f; // TODO: Get from SkillTemplate or Config
            float life = 2.0f;   // TODO: Get from SkillTemplate or Config

            auto proj = ProjectileFactory::Instance().CreateProjectile(
                room->_objMgr,
                owner->GetId(),
                _skillId,
                _typeId,
                px,
                py,
                forward.x * speed,
                forward.y * speed,
                _damage,
                life
            );

            if (proj)
            {
                room->_objMgr.AddObject(proj);
                room->_grid.Add(proj);
                room->BroadcastSpawn({proj});
            }
        }
        else
        {
            // 기본 AoE (Circular) - 즉시 데미지 (기존 로직 유지)
            std::vector<std::shared_ptr<Monster>> victims = room->GetMonstersInRange(px, py, _hitRadius);

            // 타겟 규칙 적용 (Nearest)
            if (_targetRule == "Nearest")
            {
                std::sort(
                    victims.begin(),
                    victims.end(),
                    [&](const auto &a, const auto &b)
                    {
                        float distA = Vector2::DistanceSq(Vector2(px, py), Vector2(a->GetX(), a->GetY()));
                        float distB = Vector2::DistanceSq(Vector2(px, py), Vector2(b->GetX(), b->GetY()));
                        return distA < distB;
                    }
                );
            }

            // 최대 타겟 수 제한
            int count = 0;
            for (auto &monster : victims)
            {
                if (count >= _maxTargetsPerTick)
                    break;

                monster->TakeDamage(_damage, room);
                count++;
            }
        }
    }
}

bool DamageEmitter::IsExpired() const
{
    if (!_active)
        return true;
    auto owner = _owner.lock();
    if (owner && owner->IsDead())
        return true;
    if (!owner)
        return true; // Owner is gone
    return false;
}

} // namespace SimpleGame
