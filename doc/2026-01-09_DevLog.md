# DevLog 2026-01-09: 고성능 게임 서버를 위한 비동기 DB 레이어 리팩토링

오늘의 개발 일지는 단순한 기능 구현을 넘어, 고성능 게임 서버 아키텍처에서 마주칠 수 있는 전형적인 문제(Blocking I/O)와 이를 우아하게 해결하기 위한 설계적 고민을 다룹니다. 나중에 블로그 포스팅으로 활용할 수 있도록 **[배경 - 문제 - 액션 - 해결]** 구조로 정리했습니다.

---

## 1. 배경: "메인 루프는 절대로 멈춰선 안 된다"

### 현상
기존 서버 엔진의 데이터베이스 접근은 동기식(Blocking)이었습니다. SQLite를 사용했기에 로컬에서는 큰 문제가 없었으나, 동접자가 늘어나거나 복잡한 쿼리가 발생할 경우 DB 응답을 기다리는 동안 메인 게임 루프(`Dispatcher`)가 멈추는 치명적인 구조였습니다.

### 목표
- 모든 DB I/O를 메인 스레드에서 분리하여 별도의 워커 스레드 풀에서 처리.
- 비즈니스 로직(예: `UserDB`)이 DB 비동기 처리에 대해 알 필요가 없도록 투명한 인터페이스 제공.

---

## 2. 문제 (The Critical Issue): 비동기 환경에서의 트랜잭션 붕괴

비동기화를 진행하며 가장 난해했던 지점은 **'트랜잭션 내의 커넥션 고정'** 문제였습니다.

### 액션 (시도)
처음에는 단순히 `DatabaseImpl`에 태스크를 큐잉(Queueing)하는 기능을 구현했습니다. 
- `IDatabase::QueryAsync` 호출 -> 워커 풀에서 실행 -> 결과를 메인 스레드로 Push.

### 위기의 순간
하지만 트랜잭션(`RunInTransaction`)이 도입되자 설계에 구멍이 생겼습니다.
1. `RunInTransaction` 시작 (커넥션 A 확보 및 `BEGIN` 실행)
2. 트랜잭션 내부에서 유저 정보를 조회하기 위해 `db->Query()` 호출
3. `DatabaseImpl`은 커넥션 풀로부터 비어있는 **새로운 커넥션 B**를 가져와 버림!
4. 결국 `BEGIN`은 A에서 일어났는데, 정작 쿼리는 B에서 실행되어 트랜잭션 격리성이 완전히 무너짐.

---

## 3. 해결 (Resolution): 프록시 패턴을 통한 컨텍스트 고정

이 문제를 해결하기 위해 **`DatabaseConnectionProxy`**를 도입했습니다.

### 핵심 매커니즘
`RunInTransaction`이 실행될 때, 풀에서 커넥션 하나를 미리 점유(Acquire)하고 이 커넥션에만 '고정된' 임시 DB 객체(Proxy)를 생성하여 람다 함수에 넘겨줍니다.

```cpp
// [Pseudo Code]
void RunInTransaction(transactionFunc, callback) {
    auto conn = Acquire(); // 이번 트랜잭션 전용 커넥션 확보
    DatabaseConnectionProxy proxy(conn); // 이 커넥션만 쓰는 프록시 생성
    bool success = transactionFunc(&proxy); // 프록시를 통해 쿼리 실행
    Release(conn); // 완료 후 반납
}
```

### 설계적 의의 (Blog Key Takeaways)
1. **LSP (리스코프 치환 원칙)의 극대화**:
   - 프록시는 `IDatabase` 인터페이스를 완벽히 구현합니다. 따라서 `UserDB` 같은 클래스는 자신이 "풀 관리 DB"를 쓰는지 "커넥션 고정 프록시"를 쓰는지 알 필요가 없습니다. 동일한 코드가 어디서든 재사용됩니다.
2. **비동기 태스크 환경의 한계 극복**:
   - Java/Spring 진영에서는 `ThreadLocal`을 써서 커넥션을 숨깁니다. 하지만 비동기 태스크 환경(Asio 등)은 태스크가 실행 스레드 사이를 점프하기 때문에 `ThreadLocal`이 먹히지 않습니다. 명시적인 객체(Proxy) 주입 방식이 C++ 비동기 서버에서는 가장 확실한 정해입니다.
3. **SRP (단일 책임 원칙)**:
   - `DatabaseImpl`은 '전체 커넥션 관리'에 집중하고, `Proxy`는 '특정 작업의 컨텍스트 유지'에 집중합니다.

---

## 4. 최종 결과

- **성능**: DB I/O 중에도 메인 게임 틱 타임 1ms 미만을 유지. 대량의 유저 로그인/포인트 적립 상황에서도 프레임 드랍 없음.
- **안정성**: `DatabaseAsyncTest.RunInTransactionAsync` 유닛 테스트를 통해 복합 쿼리들이 동일 커넥션에서 안전하게 커밋됨을 검증.
- **코드 품질**: 어댑터 레이어를 제거하고 `IDatabase` 인터페이스만으로 동기/비동기/트랜잭션을 모두 아우르는 통합 아키텍처 완성.

---

> **결론**: 비동기 시스템을 설계할 때 가장 무서운 것은 '상태(State)와 컨텍스트(Context)'의 유실입니다. 프록시 패턴은 이러한 컨텍스트를 코드 복잡도 증가 없이 우아하게 전달할 수 있는 강력한 도구임을 재확인했습니다.

---

## [Essay] 어느 개발자의 오후: 설계와 구현 사이의 줄타기

금요일 오후, 비교적 단순해 보였던 'DB 비동기화' 리팩토링의 8부 능선을 넘고 있었다. 

`QueryAsync`와 `ExecuteAsync`가 워커 풀에서 시원하게 돌아가고, 결과가 Dispatcher를 타고 메인 스레드로 꽂히는 걸 보며 잠시 커피 한 잔의 여유를 가졌을 때였다. 그런데 문득 `UnlockSkill` 함수의 코드가 눈에 들어왔다. 포인트 체크, 포인트 차감, 스킬 해제... 이 모든 게 하나의 트랜잭션으로 묶여야 하는 로직이었다.

머릿속으로 시뮬레이션을 돌려보다가 멈칫했다. '아, 이거 깨지겠는데?'

비동기 태스크 환경에서 `DatabaseImpl`은 쿼리가 들어올 때마다 풀에서 가장 한가한 커넥션을 빌려다 쓰고 바로 반납한다. 하지만 트랜잭션은 'A'라는 커넥션에서 문을 열었으면(`BEGIN`), 닫을 때(`COMMIT`)까지 오직 그 'A'와만 대화해야 한다. 지금 내 코드는 `BEGIN`은 A에서 하고, 정작 중요한 데이터 수정은 풀에서 새로 가져온 B에서 하려는 꼴이었다. 은행 문은 정문으로 열고, 돈은 옆 건물 창고에서 찾으려는 격이다.

잠시 고민에 빠졌다. 가장 쉬운 건 트랜잭션 함수에 `IConnection`을 직접 넘기는 거다. 하지만 그건 너무 날것의 해결책이었다. 그렇게 되면 비즈니스 로직인 `UserDB`가 `IDatabase`라는 고수준 인터페이스 대신 DB 커넥션이라는 저수준 디테일을 직접 만져야 한다. 이건 설계의 패배처럼 느껴졌다.

그때 생각난 것이 '프록시(Proxy)'였다.

트랜잭션이 돌아가는 동안만 `IDatabase`인 척하면서, 뒤로는 미리 확보해둔 특정 커넥션에만 속삭여주는 대리인을 세우는 것이다. 이렇게 하면 `UserDB`는 자기가 트랜잭션 안에 있는지조차 모른 채 평소처럼 `db->Query()`를 호출할 수 있다. 겉으로는 우아한 설계를 유지하면서, 내부적으로는 컨테이너(커넥션)를 안전하게 고정하는 방식.

프록시 객체를 구현하고 유닛 테스트를 돌렸을 때, `RunInTransactionAsync`에 초록불이 들어오던 그 순간의 쾌감은 여전하다. 구현은 조금 더 복잡해졌을지 몰라도, 시스템의 전체적인 정합성과 인터페이스의 깨끗함(Cleanliness)을 지켜냈다는 안도감이 들었다.

개발을 하다 보면 종종 "그냥 돌아가게만 만들까?" 하는 유혹에 빠진다. 하지만 오늘처럼 설계의 원칙을 지키기 위해 한 단계를 더 고민했을 때 얻는 결과물은, 단순한 코드가 아니라 미래의 나(혹은 동료)에게 주는 신뢰라는 선물이다.

오늘 밤은 편히 잠들 수 있을 것 같다.

