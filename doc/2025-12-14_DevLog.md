# 개발 로그 - 2025-12-14

## 1. Hot Path 최적화

### 목표
서버의 핵심 처리 경로에서 성능 저하 요소 제거

### 수행 작업

#### 1.1 Hot Path 영역 식별
다음 기준으로 핫패스 영역 식별:
- 패킷 1개 처리당 실행되는 경로
- 메시지 큐 dequeue 이후 처리 루프
- burst 시 호출 횟수가 선형 증가하는 함수

**식별된 Hot Path:**
| 영역 | 위치 | 스레드 |
|:---|:---|:---|
| `AsioSession::OnRead` | 네트워크 수신 | IO Thread |
| `DispatcherImpl::Post` | 큐 삽입 | IO Thread |
| `DispatcherImpl::Process` | 메시지 처리 | Logic Thread |
| `IPacketHandler::HandlePacket` | 비즈니스 로직 | Logic Thread |
| `MessagePool` | 메모리 할당/해제 | Both |

#### 1.2 금지 연산 제거

| 위반 | 위치 | 조치 |
|:---|:---|:---|
| `LOG_ERROR` (I/O) | `AsioSession::OnRead` | 제거 (Silent Close) |
| `std::make_unique` (동적 할당) | `AsioSession::OnRead` 내 Timer | `Reset()`으로 이동 (사전 할당) |
| `unordered_map` 조회 | `DispatcherImpl::Process` | 주석으로 SlotMap 권장 명시 |

---

## 2. 패킷 흐름 진단 카운터

### 목적
패킷 손실 지점 추적

### 추가된 카운터 (`MemoryMetrics.h`)
```cpp
inline static std::atomic<long long> RecvPacket = 0;   // OnRead 파싱 성공
inline static std::atomic<long long> AllocFail = 0;    // 풀 할당 실패
inline static std::atomic<long long> Posted = 0;       // Dispatcher 큐 삽입
inline static std::atomic<long long> Processed = 0;    // Dispatcher 처리
inline static std::atomic<long long> Echoed = 0;       // Echo 응답 전송
```

### 출력 예시
```
[Pkt] Recv=34837782, AllocFail=0, Posted=34837782, Processed=34837882, Echoed=34837782
```

---

## 3. 클라이언트 Graceful Shutdown

### 문제
클라이언트 종료 시 `io_context.stop()` 호출로 인해 미수신 데이터 손실

### 해결 (4-Phase Shutdown)
1. **Phase 1**: `StopSending()` - Send 중단, Recv 계속
2. **Phase 2**: Grace Period - 연속 2초 recv == 0 대기
3. **Phase 3**: `Close()` - 소켓 명시적 종료
4. **Phase 4**: `io_context.stop()` - IO 스레드 종료

---

## 4. 패킷 카운팅 정확도 문제

### 현상
```
Client Sent: 38,587,211
Server Recv: 34,837,782
Gap: 3,749,429 (9.7%)
```

### 원인 분석
`async_write` 콜백은 **OS TCP 버퍼에 복사 완료** 시점에 호출됨.
실제 TCP 전송 완료가 아님.

```
[async_write 콜백] → [OS TCP Buffer] → [네트워크 전송] → [서버 수신]
         ↑                                    ↓
    여기서 카운트                      여기서 소켓 닫힘 → 손실
```

### 해결 방안
**Echo 기반 카운팅**: Send 카운트 대신 Recv 카운트를 "실제 전송 성공" 기준으로 사용

```
========================================
 Test Finished
 Raw Sent (OS Buffer): 38,587,211 (Avg: 643,120/s)
 Confirmed (=Recv):    34,837,782 (Avg: 580,630/s)
 Loss (Shutdown):      3,749,429 (9.7%)
========================================
```

> **결론**: Echo 프로토콜에서는 `Confirmed (=Recv)`가 곧 `성공한 Send Count`입니다.
> 서버의 `Recv = Echoed = Client Recv` 이므로 **서버에 패킷 손실 없음** 확인됨.

---

## 5. 향후 개선 사항

1. **Dispatcher Map 최적화**: Session ID 재활용 로직 도입 시 `std::vector` 기반 O(1) 조회 가능
2. **MessagePool Block 사이즈 튜닝**: Burst 특성에 맞게 조절
3. **Application-Level ACK**: 정밀한 전송 성공 추적 필요 시 별도 ACK 프로토콜 구현

---

## 6. Timer Callback Lifetime 수정

### 문제
`AsioSession::OnRead`와 `OnResumeRead`에서 타이머 콜백에 `this`를 캡처하지만 `IncRef()`가 없어 Use-After-Free 가능성 존재

### 해결
```cpp
// Before (위험)
_flowControlTimer->async_wait([this](...) { OnResumeRead(ec); });

// After (안전)
IncRef();
_flowControlTimer->async_wait([this](...) {
    OnResumeRead(ec);
    DecRef();
});
```

### 수정 파일
- `AsioSession.cpp`: `OnRead` 내 타이머 + `OnResumeRead` 내 타이머

---

## 7. MessagePool / PacketPool 통합

### 문제
- **RECV 경로**: `MessagePool::AllocatePacket` 사용
- **SEND 경로**: `PacketPool::Allocate` 사용 (별도 풀!)

두 개의 풀이 존재하여 관리 복잡성 증가

### 해결
`PacketPool` 삭제, **모든 경로에서 `MessagePool` 단일 사용**

### 변경 파일
| 파일 | 변경 |
|---|---|
| `Writer.h/cpp` | `intrusive_ptr<Packet>` → `PacketMessage*` |
| `ISession.h` | Send 시그니처 변경 |
| `AsioSession.h/cpp` | `PacketPool` → `MessagePool` |
| `ServerPacketHandler.h` | Echo 응답 할당 변경 |
| `IMessage.h` | `Packet.h` include 제거, 레거시 주석 삭제 |
| `IPacketHandler.h` | `Packet.h` include 제거 |
| `DispatcherImpl.cpp` | 레거시 주석 삭제 |
| `PacketTest.cpp` | `MessagePool` 사용으로 변경 |
| `main.cpp` | `PacketPool` → `MessagePool` 호출 |
| `CMakeLists.txt` | `PacketPool.cpp` 제거 |
| `PacketPool.h/cpp` | **삭제** |

### 효과
- 풀 하나로 통합 → 캐시 효율성 증가
- 코드 단순화
- 관리 용이성 향상

---

## 8. RecvBuffer 고성능 최적화

### 문제
- 버퍼 크기 **1MB** (과도)
- `Clean()` 내 `std::copy` 호출 (최악 ~100KB 복사)
- 복사 임계값 동적 계산 (`_capacity / 10`)

### 해결

#### 버퍼 크기 조정
```cpp
// Before
int32_t bufferSize = 0x100000  // 1MB

// After
static constexpr int32_t DEFAULT_CAPACITY = 64 * 1024;  // 64KB
```

#### 복사 임계값 고정
```cpp
// Before
if (FreeSize() < _capacity / BUFFER_COUNT)  // 동적 계산

// After  
static constexpr int32_t COMPACT_THRESHOLD = 10 * 1024;  // 10KB 고정
if (FreeSize() < COMPACT_THRESHOLD)
```

#### `std::copy` → `std::memmove`
```cpp
// Before
std::copy(_buffer.begin() + _readPos, _buffer.begin() + _writePos, _buffer.begin());

// After
std::memmove(_buffer.data(), _buffer.data() + _readPos, dataSize);
```

### 효과
- 캐시 효율성 향상 (1MB → 64KB)
- 복사 빈도 감소 (임계값 명확화)
- 안전한 복사 (`memmove` = overlapping-safe)

---

## 9. Reader/Writer → AsioSession 통합

### 목표
- Reader/Writer 클래스 제거
- 모든 I/O 로직을 AsioSession 내부로 통합
- 상태 분산 제거, Lifetime 단순화

### Phase 1: Reader 제거
- `Reader::ReadSome` → `AsioSession::StartRead()`
- `Reader::OnReadComplete` → `AsioSession::OnReadComplete()`
- `AsioSession::OnRead` → `AsioSession::ProcessReceivedData()`
- 삭제: `Reader.h`, `Reader.cpp`

### Phase 2: Writer 제거
- `Writer::Send` → `AsioSession::EnqueueSend()`
- `Writer::Flush` → `AsioSession::Flush()`
- `Writer::OnWriteComplete` → `AsioSession::OnWriteComplete()`
- `Writer::Clear` → `AsioSession::ClearSendQueue()`
- 삭제: `Writer.h`, `Writer.cpp`

### 변경된 파일
| 파일 | 변경 |
|---|---|
| `AsioSession.h` | Read/Write 멤버 직접 포함, 메서드 통합 |
| `AsioSession.cpp` | 모든 I/O 로직 통합 |
| `CMakeLists.txt` | Reader.cpp, Writer.cpp 제거 |

### 효과
- **상태 분산 제거**: 모든 상태가 AsioSession에 집중
- **Lifetime 단순화**: IncRef/DecRef 패턴 명확화
- **Hot Path 최적화 유지**: 기존 성능 규칙 준수

---

## 10. 진단 카운터 조건부 컴파일

### 목적
Release 빌드에서 Hot Path atomic 연산 제거

### 적용
```cpp
#ifdef ENABLE_DIAGNOSTICS
    System::Debug::MemoryMetrics::Processed.fetch_add(1, std::memory_order_relaxed);
#endif
```

### 적용 위치
| 파일 | 카운터 |
|---|---|
| `AsioSession.cpp` | `RecvPacket`, `AllocFail`, `Posted` |
| `DispatcherImpl.cpp` | `Processed` |
| `ServerPacketHandler.h` | `Echoed` |

---

## 11. 메시지 큐 Lifetime 보호 (IncRef/DecRef)

### 문제
- `Post()` 후 세션이 풀로 반환될 수 있음
- Dispatcher 처리 시 dangling pointer 가능성

### 해결
```cpp
// AsioSession (Post 전)
IncRef();  // [Lifetime] Protect session
_dispatcher->Post(msg);

// DispatcherImpl (처리 후)
msg->session->DecRef();  // [Lifetime] Release reference
MessagePool::Free(msg);
```

### CanDestroy 조건 강화
```cpp
return !_connected.load(std::memory_order_relaxed) 
    && _ioRef.load(std::memory_order_acquire) == 0;
```

---

## 12. Dispatcher 리팩토링 - AsioSession 직접 참조

### 변경 사항
1. `_sessionRegistry` (unordered_map) 완전 제거
2. `IMessage.session` 타입: `ISession*` → `AsioSession*`
3. NETWORK_DATA 처리 시 map lookup 제거

### Before
```cpp
if (auto it = _sessionRegistry.find(msg->sessionId); it != _sessionRegistry.end())
    _packetHandler->HandlePacket(it->second, content);
```

### After
```cpp
if (session && session->IsConnected())
    _packetHandler->HandlePacket(session, content);
```

### 효과
- Hot Path에서 해시 연산 0회
- `IsConnected()` 비-virtual 호출
- Dispatcher가 AsioSession 직접 참조 (no vtable)

---

## 13. Swap-and-Pop 최적화 (ProcessPendingDestroys)

### Before (O(n))
```cpp
it = _pendingDestroy.erase(it);  // 요소 삭제 후 뒤 요소 전부 이동
```

### After (O(1))
```cpp
_pendingDestroy[i] = _pendingDestroy.back();  // 마지막 요소로 덮어쓰기
_pendingDestroy.pop_back();                    // 마지막 제거
```

### 주석
```cpp
// DO NOT REFACTOR TO erase() - This is intentional optimization.
```

---

## 14. DummyClient 레이턴시 측정 추가

### 구현
- 패킷 payload 앞 8바이트에 `steady_clock` 타임스탬프 삽입
- 수신 시 RTT 계산 (atomic 업데이트)
- min/max/avg 추적

### 출력 예시
```
[Sec 1] Connected: 500 | Send: 12345 | Recv: 12340 | AvgLat: 0.45ms

========================================
 Latency (RTT):
   Samples: 619800
   Avg:     0.43 ms
   Min:     0.12 ms
   Max:     2.31 ms
========================================
```

---

## 15. MessagePool 사전 할당 크기 조정

### 문제
- 초기 풀: 1000개
- HIGH_WATER: 5000개
- 버스트 시 4000개 런타임 alloc 발생

### 해결
```cpp
// Before
System::MessagePool::Prepare(1000);

// After
System::MessagePool::Prepare(6000);  // HIGH_WATER + 버퍼
```

### 효과
- 런타임 alloc 최소화
- Zero-alloc Hot Path 보장

---

## 16. Thread-Local Caching 확인 (Magazine Pattern)

### 현재 구현 (MessagePool)
```cpp
static thread_local L1Cache t_l1;  // 스레드당 전용 주머니

// PopBlock
if (!t_l1.buffer.empty())
    return t_l1.buffer.back();  // Lock 없음!
else
    _pool->try_dequeue_bulk(..., 500);  // 중앙에서 벌크로 가져옴

// PushBlock
if (t_l1.buffer.size() < L1_CACHE_SIZE)
    t_l1.buffer.push_back(block);  // Lock 없음!
else
    _pool->enqueue_bulk(..., 500);  // 중앙에 벌크로 반납
```

### 설정값
| 상수 | 값 |
|---|---|
| `L1_CACHE_SIZE` | 1000 |
| `BULK_TRANSFER_COUNT` | 500 |

### 효과
- 95%+ 할당이 Thread-Local에서 처리
- 중앙 풀 접근 최소화

