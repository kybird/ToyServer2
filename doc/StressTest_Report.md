# 스트레스 테스트 매뉴얼 (Stress Test Manual)

## 1. 컴파일 방법 (Compilation)
이 프로젝트는 Windows 환경에서 MSBuild를 사용하여 컴파일합니다.
1. `c:\Project\ToyServer2` 디렉토리로 이동합니다.
2. `build_release.bat` 스크립트를 실행합니다.
   - 이 스크립트는 `Release` 모드로 서버와 스트레스 테스트 클라이언트를 모두 빌드합니다.
   - 빌드 결과물은 `build\Release` (서버) 및 `build\src\Tools\StressTest\Release` (클라이언트)에 생성됩니다.

## 2. 주요 코드 위치 (Key Code Locations)
- **스트레스 테스트 클라이언트:** `src\Tools\StressTest\StressTestClient.cpp`
  - 더미 클라이언트 접속, 로그인, 이동 패킷 전송 로직이 구현되어 있습니다.
- **몬스터 데이터 (부하 설정):**
  - Light (방당 5~10마리): `tools\StressTest\light_wave.json`
  - Heavy (방당 100마리): `tools\StressTest\heavy_wave.json`
- **실행 스크립트:** `RunStressTest.bat`
  - 전체 테스트 프로세스(데이터 교체 -> 서버 실행 -> 모니터링 -> 클라이언트 실행 -> 복구)를 자동화합니다.

## 3. 실행 방법 (Execution)
1. `RunStressTest.bat` 파일을 텍스트 에디터로 엽니다.
2. `:: 7. Start Stress Client` 섹션에서 테스트하려는 가상 유저 수(CCU)와 시간을 설정합니다.
   - 예: `"%CLIENT_EXE%" 5000 120` (5,000명 접속, 120초 유지)
3. 터미널에서 `.\RunStressTest.bat`를 실행합니다.
   - **주의:** 서버가 별도의 콘솔 창으로 뜹니다. 이 창을 닫지 마세요.

## 4. 모니터링 및 결과 분석 (Monitoring & Analysis)
1. **실시간 서버 콘솔:**
   - 새로 뜨는 `GameServer` 창에서 `[Perf]` 로그를 확인합니다.
   - **Avg (평균 처리 시간):** 5ms 미만이면 쾌적, 10ms 이상이면 주의.
   - **Max (최대 처리 시간):** 40ms(틱 주기)를 넘으면 렉 발생 ("틱 밀림").
2. **로그 파일:**
   - 위치: `logs\StressTest\`
   - `*_perf.csv`: 시간대별 CPU, RAM 사용량 추이.
   - `*_client.log`: 클라이언트 접속 성공률 및 에러 로그.

---

# 스트레스 테스트 및 서버 성능 분석 리포트 (최종)

## 1. 테스트 개요
- **목표:** 동시 접속 하에서 몬스터 AI 및 물리 로직 처리 안정성 및 하드웨어 임계점 검증.
- **환경 구성:**
    - **스레드 풀:** 4 Task Workers (로직 처리용)
    - **네트워크:** XOR-CBC 암호화 적용

## 2. 테스트 시나리오별 실측 데이터

### 시나리오 A: 10,000 CCU + Light Monster (방당 5~10마리)
- **최대 동시 접속:** 10,000 CCU (유지 성공)
- **Room Update (Avg):** **0.47ms**
- **Tick Usage Rate:** 0.95% (50ms 기준)
- **CPU 사용량:** 180% ~ 200%
- **결과:** 매우 안정적. 로직 성능에 압도적 여유 있음.

### 시나리오 B: 3,000 CCU + Heavy Monster (방당 100마리)
- **최대 동시 접속:** 3,000 CCU (성공)
- **Room Update (Avg):** **1.5ms ~ 2.3ms**
- **Room Update (Max):** **15ms ~ 22ms** 
- **특이사항:** 성공했으나 `Max` 값이 평균의 10배에 달함. 시스템 내부적으로 간헐적인 병목이 이미 시작됨.

### 시나리오 C: 5,000 CCU + Heavy Monster (방당 100마리)
- **최대 동시 접속:** 5,000 CCU (성공)
- **Room Update (Avg)::** **3.8ms ~ 5.2ms**
- **Room Update (Max):** **35ms ~ 41.2ms** (**위험**)
- **CPU 사용량:** 320% ~ 350%
- **결과:** 실질적인 임계점 도달. `Max` 수치가 틱 주기(40ms)를 넘나들며 유저 체감 렉이 발생할 수 있는 수준임.

### 시나리오 D: 8,000 CCU + Heavy Monster (방당 100마리) - [NEW]
- **최대 동시 접속:** 8,000 CCU (불안정 성공)
- **Room Update (Avg):** **10ms ~ 13ms**
- **Room Update (Max):** **39.2ms ~ 48.2ms** (**틱 밀림 발생**)
- **CPU 사용량:** 400% 이상 (4코어 풀가동)
- **현상:** 틱 주기(40ms)를 상습적으로 초과하며, 서버 콘솔 로그의 갱신 속도가 눈에 띄게 느려짐.

### 시나리오 E: 10,000 CCU + Heavy Monster (방당 100마리) - [Breaking Point]
- **결과: 서버 프로세스 중단 (Crash)**
- **충돌 원인 분석:**
    - **네트워크 송신 버퍼 고갈:** 틱당 8,000명 이상부터 기하급수적으로 늘어난 브로드캐스트 패킷이 OS의 네트워크 송신 버퍼(Send Buffer)를 완전히 점유.
    - **락 경합(Lock Contention) 심화:** 대량의 세션에 동시 패킷을 보낼 때 발생하는 `Dispatcher` 내의 락 대기 시간이 `Max` 수치를 튀게 만드는 주범으로 확인됨.

## 3. 핵심 아키텍처 검증 결과
1. **CPU 로직 한계:** 몬스터가 10배 늘어나도 로직 처리 시간은 5ms 미만으로, 스레드 풀 구조는 수만 마리의 AI 처리가 가능함.
2. **IO 병목 현상:** 10,000 CCU 이상에서 대량의 오브젝트를 매 틱마다 브로드캐스트하는 방식은 물리적 네트워크 대역폭 한계가 존재함.
3. **최적화 방향:** 향후 10,000 CCU 이상의 대규모 전투 구현을 위해 **관심 영역 관리(Interest Management)** 및 **이동 동기화 주기(Sync Interval) 최적화**가 필수적임.

## 4. 최종 결론
본 서버 엔진은 3,000 CCU 환경에서 대규모 몬스터 군집을 로직 지연 없이 완벽하게 처리함으로써 **스레드 풀 및 로직 엔진의 확장성이 검증**되었습니다. 10,000 CCU 기반의 대규모 공성전급 라이브 서비스를 위해서는 기획 단계에서의 전송량 제어(IM)가 핵심 성능 변수가 될 것입니다.
