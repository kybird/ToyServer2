# Devlog: 2025-12-15 - 타이머 아키텍처 및 성능 강화

## 1. 주요 아키텍처 리팩터링: 이벤트 기반 타이머 시스템 (Event-Driven Timer System)
IO Hot-Path(유저 -> IO 스레드 -> 패킷 처리)에서 Lock 경합을 제거하기 위해 `TimerImpl` 시스템을 완전히 개편했습니다.

### 기존 (Before)
- **메커니즘**: IO 스레드가 콜백을 직접 실행하거나, 타이머 맵 접근을 위해 Lock을 획득했습니다.
- **위험요소**: `OnTimer`에서 발생하는 어떠한 Lock 경합도 전체 네트워크 IO 스레드를 차단하여, 모든 유저에게 레이턴시 스파이크를 유발했습니다.
- **복잡성**: 재진입성(Re-entrancy, 예: 콜백 내부에서 타이머 취소) 처리를 위해 `std::recursive_mutex` 같은 무거운 객체를 사용했습니다.

### 개선 후 (After): Event-Driven & Single Writer
- **메커니즘**: IO 스레드는 오직 **메시지 할당**(`TimerExpiredMessage`) 및 `Dispatcher`로의 **Post**만 수행합니다.
- **정책**: **"Zero-Touch Policy"** - IO 스레드는 공유 상태를 절대 건드리지 않습니다.
- **이점**:
    - **Hot-Path 안전성**: IO 루프가 Lock-Free이며 Non-blocking입니다.
    - **스레드 안전성**: 모든 상태 변경(`_timers` 맵 등)은 사실상 단일 스레드(Dispatcher Consumer)에서 수행되므로, 로직 레이어에서 Mutex가 필요 없습니다.

## 2. 인터페이스 개선 및 결합도 완화 (Decoupling)
### 독립적인 `ITimerListener` (Standalone)
- **문제점**: `ITimer::IListener`가 내부 클래스(Inner Class)여서 강한 결합이 발생했습니다. 사용자는 반드시 `ITimer.h`를 include 해야 했고, 전방 선언이 불가능했습니다.
- **해결**: `struct ITimerListener`를 `System` 네임스페이스 직속으로 분리했습니다.
- **결과**: `IMessage.h` 등에서 전방 선언(`struct ITimerListener;`)만으로 포인터를 사용할 수 있어, 순환 참조 위험을 제거하고 컴파일 속도를 높였습니다.

### 강력한 ID 분리 (Strong ID Handling)
- **분리**:
    - `uint64_t TimerHandle`: 시스템 내부 식별자 (O(1) 취소용).
    - `uint32_t logicTimerId`: 기획/로직용 ID (예: SkillID, BuffID).
- **흐름**: `SetTimer` -> `TimerAddMessage` (두 ID 모두 전달) -> `TimerEntry`에 LogicID 저장 -> `OnTimerExpired` 시 유저에게 LogicID 전달.

### WeakPtr Locking 정책
- **결정**: 생산자(IO/타 스레드)는 `weak_ptr`가 만료되었더라도 중단(Abort)하지 않습니다. Map Key(주소) 획득을 위해 잠시 `lock()` 할 뿐입니다.
- **검증**: 엄격한 수명 검증은 **소비 시점(Dispatcher 로직)**에서만 수행하여, 생산자 구간을 빠르고 Lock 경합 없이 유지합니다.

## 3. 문서화
- **신규 산출물**: `architecture_guidelines.md`
    - "Single Writer Principle", "IO Purity" 등 고성능 아키텍처의 "6가지 대원칙"을 문서화했습니다.
