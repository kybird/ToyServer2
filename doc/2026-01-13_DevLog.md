# 2026-01-13 개발 로그 (종합)

## 📝 오늘 수행한 작업 요약

오늘은 서버와 클라이언트 양쪽에서 **전투 시스템의 기본 구현(MVP)**을 완료하고, 고질적인 **동기화 문제**를 해결하는 데 집중했습니다. 또한 개발 생산성을 높이기 위해 **빌드 환경 최적화**도 함께 진행했습니다.

### 1. 🐛 틱 동기화(Tick Sync) 및 네트워크 디버깅
- **문제**: 클라이언트와 서버 간의 `GameTick`이 일치하지 않고, 클라이언트에서 `GameTick=0.0`으로 고정되거나 `Behind` 값이 치솟는 동기화 문제가 발생.
- **원인**:
  - `S_SpawnObject` 패킷에 `server_tick` 정보가 누락되거나 0으로 설정됨.
  - 클라이언트의 `DeadReckoning` 로직이 초기화되지 않은 틱 정보를 참조.
- **해결**:
  - 서버 패킷 생성 로직 수정: `AllocPacket` 시점에 현재 `WorldTick`을 정확히 주입하도록 변경.
  - 클라이언트 보간 로직 보완: 서버 틱을 수신할 때까지 예측 이동을 제한하거나 보정하도록 처리.
  - 결과: 로그상에서 `[TickSync]`가 안정화되고 "Ghost Hit" 현상 완화.

### 2. ⚔️ 전투 시스템 (Combat MVP) 구현
- **자동 공격 시스템 (Auto-Attack)**:
  - 하드코딩된 로직을 데이터 기반(Data-Driven)으로 리팩토링.
  - `Monster`와 `Player` 간의 상호작용 구조 개선.
- **투사체(Projectile) 구현**:
  - 서버: 투사체 생성, 이동, 충돌 판정(Collision) 로직 구현. (자신이 쏜 투사체에 맞지 않도록 예외 처리)
  - 클라이언트: `S_SpawnObject(PROJECTILE)` 패킷 수신 시 시각적 프리팹 생성 및 이동 동기화.
- **피격 및 데미지 처리**:
  - `DamageEmitter`를 통해 데미지 판정 일원화.
  - 클라이언트에서 `S_DamageEffect`, `S_HpChange` 패킷 처리하여 HP 바 갱신 및 데미지 폰트 출력.

### 3. 🚀 빌드 최적화 (Build Optimization)
- **문제**: `VampireSurvivorServer` 컴파일 속도 저하 및 불필요한 재빌드.
- **해결**:
  - CMake `target_precompile_headers`를 사용하여 PCH 파일 적용.
  - 테스트 프로젝트(`UnitTests`)와 분리하여 필요한 타겟만 빌드하는 스크립트 워크플로우 정립.

---

## 🚀 기술 블로그 포스팅 초안

### 제목: [DevLog] 동기화 지옥 탈출과 전투 시스템 MVP 구현하기

MMO나 실시간 멀티플레이 게임을 만들다 보면 가장 골치 아픈 것이 바로 **"내 화면에선 피했는데 왜 맞았지?"** 라는 동기화 문제입니다. 오늘은 뱀파이어 서바이벌 모작 프로젝트에서 이 동기화 문제를 잡고, 기본적인 전투 시스템을 올리는 과정을 정리해 봅니다.

#### 💡 오늘의 도전 1: 멈춰버린 시간, `GameTick=0.0`
전투 시스템을 테스트하는데, 몬스터가 제자리 걸음을 하거나 유저 위치가 서버와 따로 노는 현상이 발생했습니다. 로그를 까보니 클라이언트의 `GameTick`이 영원히 `0.0`에 머물러 있었습니다. 

서버는 열심히 틱을 굴리고 있는데 클라이언트는 시간이 멈춘 세상에서 살고 있었던 거죠. 원인은 **초기 스폰 패킷(`S_SpawnObject`)에 서버의 현재 시간(Tick) 정보가 제대로 실리지 않았던 실수**였습니다. 단순한 변수 할당 누락이 거창한 "동기화 오류"로 이어진 케이스입니다.

#### 🛠 해결 과정: 패킷의 생명주기 점검
패킷을 생성(`Alloc`)하고 보내는(`Send`) 과정 전수 조사를 통해, `ServerTick` 필드가 초기화되는 시점을 `PacketBuilder` 내부로 강제했습니다. 이로써 어떤 패킷이든 서버의 타임스탬프(*WorldTick*)가 필수로 박히도록 구조를 개선했습니다.

```cpp
// Before: 실수로 tick 설정을 빼먹기 쉬움
auto packet = PacketBuilder::Alloc(PKG_S_WAIT_ROOM);
// ... tick 설정 누락 ...

// After: 빌더 생성 시 강제 주입
auto packet = PacketBuilder::Alloc(PKG_S_WAIT_ROOM, GetWorldTick());
```

#### 💡 오늘의 도전 2: 나는 나를 공격할 수 없다 (Projectile Collision)
투사체 시스템을 만들었는데, 총알을 쏘자마자 플레이어 자신이 데미지를 입고 죽어버리는 황당한 일이 벌어졌습니다. 투사체의 충돌체(Collider)가 생성되자마자 발사한 주체(Owner)와 겹쳐있기 때문에 발생한 문제입니다.

#### 🛠 해결 과정: 소유자 예외 처리
충돌 처리 로직에 `OwnerId`를 확인하는 간단한 방어 코드를 추가했습니다.
```cpp
if (target->GetId() == m_OwnerId) return; // 자기가 쏜 거엔 맞지 말자
```
여기에 더해, 서버 사이드에서는 **투사체와 플레이어의 충돌 레이어**를 아예 분리하여 성능 낭비를 막았습니다.

#### 📝 배운 점 & 인사이트
1.  **네트워크 시간 동기화(Dead Reckoning)**는 게임의 생명줄입니다. 아주 작은 틱 오차도 시각적으로는 큰 떨림(Jitter)으로 나타납니다.
2.  **데이터 기반 설계**: 초기에는 하드코딩으로 빠르게 기능을 구현하더라도, 결국 확장성을 위해서는 JSON이나 DB 테이블로 수치를 빼는 **Data-Driven** 리팩토링이 반드시 필요합니다.
3.  **빌드 시간 단축**: 기능이 많아질수록 컴파일 시간이 기하급수적으로 늘어납니다. PCH(Precompiled Header) 적용은 선택이 아닌 필수입니다. 오늘 PCH 적용으로 커피 마실 시간이 줄어들었습니다(?) ☕

이제 기본 전투가 되니 게임다운 모습이 갖춰지기 시작했네요. 다음 목표는 몬스터 웨이브 시스템 고도화입니다! 🧟‍♂️🧟‍♀️
