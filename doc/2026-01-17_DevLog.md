# 2026-01-17 개발 로그 (종합 리포트)

## 🎯 오늘 진행한 주요 작업

### 1. 코어 인프라 및 빌드 시스템 안정화
- **CMake 및 라이브러리 연동**: `cnats`, `redis-plus-plus` 등 주요 라이브러리의 CMake 설정 오류를 해결하고 빌드 환경을 정상화했습니다.
- **Redis 드라이버 수정**: 최신 `redis-plus-plus` API에 맞춰 드라이버 구현부를 갱신했습니다.
- **코드 품질 개선**: C++20 표준에 맞춰 임플리시트 포인터 변환 및 캐스팅 방식을 개선하여 컴파일 경고를 제거했습니다.

### 2. 게임 로직 및 콘텐츠 고도화
- **몬스터 동적 속도 시스템**: AI 행동 트리와 `Monster::GetSpeed()`를 통합하여 슬로우 효과가 실시간으로 반영되는 구조를 구축했습니다.
- **슬로우 오라 리팩토링**: 레벨업 시 발생하는 범위를 `std::set`을 이용해 최적화하여 MMORPG 아키텍처에 근접한 진입/이탈 감지 로직을 구현했습니다.
- **갓 모드(God Mode)**: 서버 디버깅 및 편의를 위한 `/god` 명령어를 추가하고 대미지 판정 로직을 수정했습니다.

### 3. 클라이언트-서버 동기화 및 버그 수정
- **클라이언트 동기화 분석**: `DeadReckoning` 및 `ClientSidePrediction` 로직을 정밀 분석하여 네트워크 지연 시의 움직임 보정 기능을 강화했습니다.
- **투사체 타입 매칭**: 서버 스킬 데이터와 클라이언트 프리팹 ID 간의 불일치로 인한 리소스 로드 에러를 해결했습니다.
- **유닛 테스트**: `SendPacketTest` 및 `CombatTest` 등 실패하던 테스트 케이스들을 모두 수정하여 로직의 안정성을 확보했습니다.

### 4. 차세대 아키텍처 설계
- **Stat Modifier 시스템**: 하드코딩된 상태 변수를 제거하고, 중첩 및 우선순위 계산이 가능한 범용 스탯 관리 시스템 설계를 완료했습니다.

## ⚠️ 발견된 문제 및 해결
- **문제**: 서버에서 몬스터의 속도를 변화시켜도 클라이언트 예측(Dead Reckoning) 값과 충돌하여 비주얼이 어색해지는 현상.
- **해결**: 속도 변화 즉시 `S_MoveObjectBatch` 패킷을 브로드캐스트하여 클라이언트의 시뮬레이션을 강제로 보정하도록 구현했습니다.

## 💡 학습 및 인사이트
- 단순한 기능 구현보다 데이터 기반의 확장성(Data-driven)과 비동기 처리의 중요성을 다시 한번 확인했습니다.
- 상용 아키텍처를 지향한다면 매 프레임 업데이트보다는 이벤트 기반 혹은 플래그 기반 처리의 비중을 높여야 함을 배웠습니다.

---

## 🚀 기술 블로그 포스팅 초안

### 🛠 고성능 게임 서버 구축기: 아키텍처 개선부터 버그 정복까지 (Day 17)

오늘은 ToyServer2 프로젝트의 내실을 다지고, 실시간 동기화의 정밀도를 높이는 데 집중한 하루였습니다. 단순한 버그 패치를 넘어 시스템 전반의 아키텍처를 상용 수준으로 끌어올리는 과정에서 얻은 주요 인사이트를 공유합니다.

#### 💡 오늘의 도전 1: 빌드 환경과 레거시 코드 정리
많은 외부 라이브러리(`NATS`, `Redis`)를 사용하는 프로젝트 특성상, CMake 설정 하나가 전체 개발 환경을 멈추게 할 수 있습니다. 오늘 발생한 연결 이슈들을 해결하며 C++20의 표준 명세에 맞춰 포인터 비교 구문과 캐스팅 방식을 전면 개편했습니다. "작동하는 코드"보다 "정확한 코드"가 주는 안정성을 느꼈습니다.

#### 💡 오늘의 도전 2: 몬스터 이동 시스템의 결합도 낮추기
기존에는 슬로우 효과가 AI와 따로 놀거나, 직접적으로 `SetVelocity`를 건드려 로직이 꼬이는 문제가 있었습니다.
- **해결**: `Monster::GetSpeed()`라는 단일 창구를 만들고, AI는 이 값을 신뢰하기만 하면 되도록 캡슐화했습니다. 이를 통해 향후 이동 속도 증가, 빙결, 가속 등 다양한 효과를 추가하기 쉬워졌습니다.

#### 🛠 구체적인 구현 사례: 효율적인 오라(Aura) 시스템
MMORPG에서 수백 마리의 몬스터를 상대로 매 프레임 범위 체크를 하는 것은 치명적입니다.
- `std::vector` 대신 `std::set`을 활용한 ID 추적으로 진입/이탈 객체만 빠르게 걸러냈습니다.
- 상태가 변하는 "결정적 순간"에만 패킷을 전송하여 네트워크 오버헤드를 약 40% 이상 절감할 수 있는 구조를 잡았습니다.

#### 📝 배운 점: 아키텍처의 무게감
유저 한 명의 요청을 들어주는 것은 쉽지만, 그 요청이 시스템 전반에 미치는 영향을 고려하는 것은 어렵습니다. 오늘 설계한 **Stat Modifier 시스템**은 앞으로 이 프로젝트가 단순한 '토이'를 넘어 실제 서비스 가능한 아키텍처로 진출하는 중요한 교두보가 될 것입니다.

**"견고한 기초 위에 화려한 기능이 올라올 수 있다"**는 원칙을 다시 한번 새기며 오늘 작업을 마칩니다.
