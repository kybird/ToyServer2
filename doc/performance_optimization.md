# 고성능 서버 메인 루프 최적화 기술 가이드

이 문서는 서버의 메인 루프에서 CPU 자원을 효율적으로 사용하면서도 지연 시간을 최소화하는 "Condition Variable 기반 알림 체계"에 대해 설명합니다.

## 1. 배경: 기존 Busy-wait 방식의 문제점

현재 프레임워크는 다음과 같은 형태의 메인 루프를 사용하고 있었습니다:

```cpp
while (_running) {
    if (_dispatcher->Process()) continue;
    else std::this_thread::yield();
}
```

- **문제점**: `yield()`는 CPU 제어권을 OS에 일시적으로 넘기지만, 대기 중인 다른 프로세스가 없으면 즉시 현재 스레드에 제어권이 돌아옵니다. 이로 인해 패킷이 없는 유휴 상태에서도 CPU 코어 하나가 100% 점유율을 기록하며 불필요한 전력 소모와 발열을 유발합니다.

## 2. 대안 방식 비교

| 방식 | CPU 점유율 (Idle) | 지연 시간 (Latency) | 비고 |
| :--- | :--- | :--- | :--- |
| **Busy-wait (Yield)** | **100%** | 최하 (즉시 실행) | 자원 낭비가 매우 심함 |
| **Sleep (1ms)** | 1% 미만 | **높음 (~15ms)** | OS 스케줄러 주기에 따라 응답 지연 발생 |
| **Condition Variable** | **1% 미만** | **최하 (즉시 깨어남)** | **추천 방식** |

## 3. 핵심 기술: Condition Variable 알림 (CV-Notification)

Condition Variable(조건 변수)을 활용하면 스레드를 완전히 "잠재운" 상태(Wait)로 두었다가, 데이터가 들어오는 순간 "깨우는"(Notify) 메커니즘을 구현할 수 있습니다.

### 작동 원리

1.  **스레드 대기 (Wait)**: 메인 루프에서 처리할 메시지가 없으면 `wait_for`를 호출합니다. 이때 스레드는 CPU 사용을 멈추고 OS 커널에 의해 잠들게 됩니다.
2.  **데이터 도착 알림 (Notify)**: 네트워크 IO 스레드가 새로운 패킷을 큐에 넣을 때(`Post`), 잠들어 있는 메인 스레드에 신호를 보냅니다(`notify_one`).
3.  **즉각적인 깨어남**: 신호를 받은 메인 스레드는 즉시(`microsecond` 단위) 잠에서 깨어나 패킷을 처리합니다.

### 이점

- **Zero CPU Idle**: 패킷이 없을 때는 CPU를 전혀 사용하지 않습니다.
- **Near-Zero Latency**: 패킷이 들어오는 즉시 깨어나므로 `Sleep` 방식처럼 스케줄링 주기를 기다릴 필요가 없습니다.
- **전력 및 성능 효율**: 불필요한 코어 점유를 막아 다른 작업(AI, 로직 등)에 자원을 양보할 수 있습니다.

## 4. 적용 계획

1.  `IDispatcher::Wait()` 인터페이스 추가
2.  `DispatcherImpl::Post()` 시점에 알림 로직 추가
3.  `Framework::Run()`에서 `yield()` 대신 `Wait()` 사용

이 기술을 통해 서버의 안정성과 성능을 한 단계 더 끌어올릴 수 있습니다.
