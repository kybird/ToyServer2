# 개발 로그: 2025-12-12

## 요약 (Summary)
오늘의 작업은 의존성 관리 개선을 위한 아키텍처 리팩토링, 패킷 디스패칭 성능 최적화, 그리고 포괄적인 프로젝트 문서화에 집중되었습니다.

## 주요 변경 사항 (Key Changes)

### 1. 리팩토링: AsioSession 의존성 주입 (DI)
- **목표**: `AsioSession`에서 전역 `GetDispatcher()`에 대한 암시적 의존성을 제거하고 명시적인 의존성 주입을 사용합니다.
- **구현**:
    - `IDispatcher*` 전달 흐름 구축: **`Framework`** -> **`AsioService`** -> **`SessionFactory`** -> **`AsioSession`**.
    - **`AsioSession`**: `IDispatcher*` 멤버 변수 추가 및 `Reset()`을 통한 주입.
    - **`DispatcherImpl`**: `GetDispatcher()`/`SetGlobalDispatcher` 정적 접근자 및 전역 인스턴스 제거.
    - **검증**: `DummyClient` 에코 테스트를 통해 세션이 주입된 디스패처와 올바르게 통신함을 확인.

### 2. 최적화: 락-프리 세션 디스패칭 (Lock-Free Session Dispatching)
- **목표**: `Dispatcher`의 패킷 처리 중 발생하는 `SessionFactory::FindSession` 락 경합(Lock Contention) 제거.
- **구현**:
    - **`SystemMessage`**: `std::shared_ptr<ISession>` 필드 추가.
    - **`AsioSession`**: `NETWORK_DATA`, `CONNECT`, `DISCONNECT` 메시지 전송 시 `shared_from_this()`를 직접 담아서 전달.
    - **`DispatcherImpl`**: `SessionMap` 검색을 우회하고 `SystemMessage`에 담긴 포인터를 직접 사용.
- **결과**: 네트워크 스레드(연결/종료)와 로직 스레드(패킷 처리) 간의 락 경합 감소.

### 3. 문서화 및 표준 (Documentation & Standards)
- **`doc/coding_convention.md`**: 디렉토리 구조(인터페이스/구현 분리), 네이밍 규칙(`I` 접두어, `Manager` 지양), DI 패턴 등을 문서화.
- **`README.md`**: 프로젝트 소개, 기능(크로스 플랫폼, C++20), 빌드 가이드(Vcpkg + CMake)를 포함한 포괄적인 설명 문서 생성 (한글).
- **`LICENSE`**: 저작권 표시 의무가 있는 **BSD 3-Clause License** 적용 (영문).
- **`.gitignore`**: `build/`, `vcpkg_installed/`, 로그, 덤프 파일 등에 대한 무시 규칙 추가.

### 5. 타이머 리팩토링 (Timer Refactoring)
- **위치 변경**: `AsioTimer` 구현체를 `src/System/Timer/ASIO/` 디렉토리로 이동하여 인터페이스와 분리.
- **전역 접근 제거**: `System::GetTimer()` 제거 및 `Framework::GetTimer()`를 통한 의존성 주입 사용.

### 7. Graceful Shutdown & Memory Verification
- **Signal Handling**: `main.cpp`에 `SIGINT` (Ctrl+C), `SIGTERM` 핸들러 구현.
- **Framework Shutdown**: `Framework::Stop()`을 통해 메인 루프 및 워커 스레드 정상 종료 지원.
- **Memory Cleanup**: 종료 시 `PacketPool::Clear()` 및 `ObjectPool` 소멸자를 통해 풀링된 객체를 명시적으로 해제.
- **Verification**: 종료 직전 `active allocations` 로그를 출력하여 메모리 정리 상태 검증 가능.

### 8. Async Lifetime Safety Fixes
- **AsioSession Crash 방지**: `Reader::ReadSome` 및 `Writer::Flush`의 비동기 콜백 람다에서 `[this]`만 캡처하던 것을 `[this, self = _owner->shared_from_this()]`로 수정.
- **효과**: 세션이 끊겨도 비동기 작업이 완료될 때까지 세션 객체의 수명이 연장되어 `Use-After-Free` 크래시 방지.

### 9. DummyClient Crash Fix (Race Condition)
- **증상**: `Debug Assertion Failed: can't dereference out of range vector iterator`.
- **원인**: `ClientSession::SendLoop`에서 `static std::vector`를 사용하여 송신 버퍼를 재사용. 멀티스레드(4개) 환경에서 500개 세션이 동시에 `static` 벡터에 접근, `resize` 및 `write`를 수행하여 메모리 손상 및 이터레이터 무효화 발생.
- **해결**: `static` 제거 및 `ClientSession` 멤버 변수 `_sendBuf` 도입으로 세션별 독립적인 송신 버퍼 보장.

### 10. AsioSession Memory Leak Fix
- **증상**: 서버 구동 후 DummyClient 연결/해제를 반복하면 메모리 할당량이 계속 증가하며, `~AsioSession`이 호출되지 않음.
- **원인**: `Writer` 에러(또는 로직 상의 `Close`) 발생 시 `Socket::close`가 호출되어 `Reader`가 `operation_aborted` 에러를 받음. 기존 코드는 `aborted`일 때 `OnDisconnect`를 호출하지 않았음. 이로 인해 `SessionFactory::RemoveSession`이 실행되지 않아 맵에 세션이 영구히 남음.
- **해결**: `std::atomic<bool> _connected` 플래그를 도입하고, `Close()` 호출 시에도 강제로 `OnDisconnect()`를 수행하도록 수정. `OnDisconnect`는 `exchange`를 사용하여 중복 호출을 방지하고 `RemoveSession` 메시지를 한 번만 전송하도록 보장함.

### 11. Memory Accumulation Fix (Writer Queue Reuse)
- **증상**: `Active Allocations`이 더미클라이언트 재실행 시마다 계단식으로 증가(수백만 단위). `PacketPool`, `SessionPool` 수치는 안정적이나 실제 메모리 사용량이 치솟음.
- **원인**: `Writer` 클래스가 `AsioSession`의 멤버 변수로 재사용됨. `Writer` 내부의 `_sendQueue(std::deque)`가 세션 종료 시 비워지지 않고, `Writer::Init`에서도 초기화되지 않음. 이로 인해 이전 세션의 미전송 패킷들이 큐에 계속 쌓임.
- **해결**: `Writer::Init`에서 `_sendQueue`를 루프를 돌며 비우는 코드 추가.

### 12. AsioTimer Circular Reference Fix
- **증상**: `SetInterval` 사용 시 미세한 메모리 증가 가능성 (이론적 확인).
- **원인**: `SetInterval` 구현에서 재귀 람다(`recursive`)가 자기 자신을 담은 `shared_ptr`를 값으로 캡처함. (`shared_ptr` -> `lambda` -> `shared_ptr` 순환 참조 발생)
- **해결**: `std::weak_ptr`를 사용하여 순환 참조 고리를 끊음.

### 13. Memory Accumulation Analysis (High Water Mark)
- **증상**: `Active Allocations`이 240만 개 수준에서 줄어들지 않음.
- **분석**: 로그 확인 결과 `Queue`가 117만 개까지 치솟는 병목 현상 발생. 이를 처리하기 위해 `PacketPool`이 120만 개까지 확장됨. `Queue`가 0이 된 후 `PktPool`이 120만 개로 유지됨.
- **결과**: `Alloc(240만)` ≈ `PktPool(120만)` × 2 (Vector + SharedPtr ControlBlock). 메모리 누수가 아니라 **Peak Load에 맞춘 풀 확장(High Water Mark)** 현상임이 증명됨.
- **향후 과제**: Dispatcher 처리 속도 개선 또는 Backpressure(큐 제한) 구현 필요.

## 다음 단계 (Next Steps)
- `DummyClient` 로직 기능 구현 계속.
- 로직 레이어(Logic Layer) 구현 탐색.
