# 2025-12-19 개발 일지 (DevLog)

## 금일 작업 요약 (Overall Work Summary)

오늘의 주요 작업은 **클라이언트-서버 로비 입장 플로우 디버깅** 및 **Rate Limiter 버그 수정**입니다.

---

## 1. 문제 상황 (Issue)

### 증상
- 클라이언트가 로그인(`C_LOGIN`) 후 `S_LOGIN` 응답을 받으면 로비 입장(`C_ENTER_LOBBY`) 패킷을 보냄
- **서버에서 `C_ENTER_LOBBY` (ID=110) 패킷이 처리되지 않음**
- 클라이언트 로그: `[Recv] S_LOGIN` 후 멈춤
- 서버 로그: `Login Auth Success` 후 `Session Entered Lobby` 로그 없음

### 초기 의심점
1. 패킷 헤더 불일치 (`SimpleGame::PacketHeader` vs `Share::PacketHeader`)
2. Dispatcher 큐 오버로드
3. 세션 라이프사이클 문제

---

## 2. 디버깅 과정 (Debugging Process)

### Phase 1: 패킷 수신 확인
`Session::OnRecv`에 상세 로그 추가:
```cpp
LOG_INFO("Session {} Recv Bytes: {}", _id, bytesTransferred);
LOG_INFO("Session {} OnRecv Loop: dataSize={}", _id, dataSize);
```

**결과**: 
- `Session 1 Recv Bytes: 4` → 4바이트(C_ENTER_LOBBY 헤더) 수신 확인
- `OnRecv Loop` 로그가 없음 → **while 루프에 진입하기 전에 리턴되고 있음!**

### Phase 2: Rate Limiter 의심
`Session::OnRecv` 시작 부분의 Rate Limiter 체크에 경고 로그 추가:
```cpp
if (!_ingressLimiter.TryConsume(1.0))
{
    LOG_WARN("Session {} Rate Limited! (violation: {})", _id, _violationCount);
    ...
    return;
}
```

**결과**:
```
Session 1 Recv Bytes: 4
Session 1 Rate Limited! (violation: 0)  ← 원인 확정!
```

---

## 3. 근본 원인 (Root Cause)

### RateLimiter 기본값 문제

`RateLimiter.h`의 생성자:
```cpp
// 문제 코드
RateLimiter(double rate = 1.0, double burst = 1.0)
```

- **기본값이 `rate=1.0, burst=1.0`** (초당 1개 패킷만 허용!)
- `Session` 클래스에서 `_ingressLimiter`가 **기본 생성자**로 초기화됨
- 설정 파일의 `rate_limit: 100, rate_burst: 200` 값이 적용되지 않음

### 발생 시나리오
1. 클라이언트에서 `sleep_for(500ms)` 제거
2. `C_LOGIN` 직후 `C_ENTER_LOBBY` 즉시 전송 (거의 동시)
3. 첫 번째 패킷이 1개의 토큰 소비
4. 두 번째 패킷 도착 시 토큰 부족 → **Rate Limited!**

---

## 4. 해결 방법 (Solution)

### 수정 사항
`src/System/Network/RateLimiter.h`:
```diff
- RateLimiter(double rate = 1.0, double burst = 1.0)
+ RateLimiter(double rate = 100.0, double burst = 200.0)
```

### 후속 개선 (TODO)
- [ ] `Session::Reset`에서 설정 파일의 `rate_limit`, `rate_burst` 값을 `_ingressLimiter.UpdateConfig()`로 적용
- [ ] 설정값이 런타임에 동적으로 반영되도록 개선

---

## 5. 추가 수정 사항

### 5.1. 스레드 수 불일치 해결
**문제**: 서버 로그에 32개 스레드 시작, 설정 파일은 4개 지정  
**원인**: `JsonConfigLoader`가 `worker_threads` 키를 찾았으나, `simple_game_config.json`은 `workerThreadCount` 사용  
**해결**: `JsonConfigLoader`가 두 가지 키 이름 모두 지원하도록 수정

### 5.2. 디버그 로그 정리
오류 상황에서만 출력되는 로그만 남기고 상세 디버그 로그 제거:
- `Session::OnRecv`: `Rate Limited!`, `Packet Too Large` 로그만 유지
- `DispatcherImpl`: 상세 dequeue 로그 제거
- `Framework`: Heartbeat 로그 제거
- `GamePacketHandler`: `HandlePacket: ID=X` 로그 제거

---

## 6. 기술적 교훈 (Technical Lessons)

### Rate Limiter 초기화의 중요성
- 기본값이 지나치게 보수적이면 정상 트래픽도 차단될 수 있음
- 설정 파일 값이 실제로 적용되는지 **반드시 검증** 필요

### 비동기 패킷 전송의 특성
- `sleep_for` 제거 시 패킷이 거의 동시에 도착할 수 있음
- Rate Limiter, 버퍼 오버플로우 등 **버스트 트래픽 시나리오** 테스트 필수

### 디버깅 로그 전략
1. 핫패스(Hot Path)에는 **조건부 로그**만 사용 (오류 상황)
2. 정상 동작 시에는 **최소한의 로그**로 성능 유지
3. 문제 발생 시 **임시 상세 로그** 추가 후 해결 시 제거
