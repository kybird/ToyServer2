# 2026-02-19 DevLog: The Great Packet Crash & System Audit

## 1. 개요 (Overview)
오늘 하루는 **"서버가 왜 10분만 지나면 죽어버리는가?"**에 대한 답을 찾는 치열한 디버깅의 연속이었다.
결국 범인은 **"너무 큰 패킷(Large Packet)"**과 이를 처리하는 **"자료형 한계(Integer Truncation)"**였다.
이 문제를 해결한 후, 재발 방지를 위해 `src/System` 전체를 감사(Audit)하여 숨어있던 병목 구간들을 찾아냈다.

---

## 2. 핵심 사건: The Great S_MoveObjectBatch Crash

### 2.1. 증상 (Symptoms)
*   게임 시작 후 몬스터와 투사체가 수천 개(약 2,500+) 쌓이면, `Release` 빌드에서만 서버가 `Segmentation Fault`나 `Heap Corruption`으로 사망.
*   로그에는 아무런 에러 메시지도 남지 않음 (Silent Crash).

### 2.2. 삽질의 기록 (Failed Hypotheses)
*   ❌ **가설 1: 부동소수점 오류(NaN/Inf)**: 물리 연산 중 0으로 나누기가 발생?
    *   -> `Tests/CrashReproductionTests.cpp`에서 `NaN`을 넣어도 Protobuf는 잘 버팀. (기각)
*   ❌ **가설 2: Race Condition**: 리스트 순회 중 삽입/삭제?
    *   -> 모든 로직은 단일 스레드(`Dispatcher`)에서 돔. (기각)

### 2.3. 진범 검거: Integer Truncation
*   **원인**:
    *   `PacketHeader::size`는 `uint16_t` (최대 65,535).
    *   몬스터 2,500마리 패킷 크기는 약 **87,000 바이트**.
    *   `CalculateSafeSize()`가 `87,000`을 반환했지만, `uint16_t`로 캐스팅되면서 **21,464(0x53D8)**로 잘림.
    *   `MessagePool`은 **21KB**만 할당했는데, 직렬화 함수(`SerializeToArray`)는 **87KB**를 덮어씀 -> **66KB Heap Corruption 발생**.

### 2.4. 해결책 (Solutions)
1.  **Safety Enforce**: `PacketBase.h`에서 `MaxPacketSize`를 65,535로 강제 제한. 초과 시 `Abort`.
2.  **Packet Chunking**: `Room_Update.cpp`에서 몬스터 이동 패킷을 **300마리 단위**로 끊어서 전송.

---

## 3. 후속 사건: The `safeSize` Regression

### 3.1. 문제 발생
*   패킷 크래시 수정 직후, 클라이언트가 로그인 패킷(`C_LOGIN`) 이후 데이터를 못 받음.
*   원인은 **"너무 안전하게 하려다 망친"** 코딩.

### 3.2. 원인 분석
*   `safeSize` 로직으로 할당 크기(`msg->length`)를 패킷 실제 크기보다 크게 설정.
*   남는 공간에 들어있던 **쓰레기 값(Garbage)**이 TCP로 전송됨.
*   클라이언트 파서가 쓰레기 값을 다음 패킷 헤더로 오인하고 파싱 실패.

### 3.3. 해결
*   `safeSize` 제거. `ByteSizeLong()`을 신뢰하고 **정확한 크기**만큼만 할당.

---

## 4. 사후 분석: System Framework Audit (Post-mortem)

크래시 해결 후, "왜 이런 구조적 결함을 미리 못 봤을까?" 하는 반성으로 `src/System` 전수 감사를 수행했습니다.

### 4.1. 주요 발견 (Findings)
*   **Infrastructure Mismatch**:
    *   `UDPNetworkImpl`: **Zero-Copy**와 **Context Pool**로 무장한 최상급 인프라.
    *   `UDPSession`: 정작 패킷 보낼 때 `std::vector`를 힙 할당하여 인프라 성능을 깎아먹음 (**Hot Path Violation**).
*   **Directory Mess**: `Dispatcher/DISPATCHER` 같은 중복 폴더 발견.

### 4.2. 향후 계획 (Next Steps)
*   [ ] `UDPSession` 힙 할당 제거 (Priority 1).
*   [ ] 디렉토리 구조 평탄화 및 인터페이스 정리 (Priority 2).
*   [ ] `Vector2`, `SpatialGrid` 등 유틸리티 프레임워크 승격 (Priority 3).

## 🔗 참조 문서
*   `doc/learning/2026_02_19_Protobuf_Crash_Analysis.md`
*   `doc/code_review/2026_02_19_System_Audit_Report.md`

---

## 🚀 기술 블로그 포스팅 초안: "서버가 매번 10분 만에 죽는 이유" (Protobuf Crash 디버깅 일지)

### 💡 오늘의 도전: 미궁에 빠진 크래시
잘 돌아가던 서버가 몬스터가 2,500마리쯤 되는 시점, 정확히 실행 10분 만에 아무런 에러 로그도 없이 **`Segmentation Fault`**로 죽었습니다.
처음엔 부동소수점(`NaN`) 문제인가? 아니면 멀티스레드 동기화(`Race Condition`) 문제인가? 하고 엉뚱한 곳만 팠습니다.

### 🛠 해결 과정: "숫자가 잘렸다" (Integer Truncation)
`CrashReproductionTests`를 작성하며 온갖 경우의 수를 대입해보다가, **패킷 크기**에 주목했습니다.
1.  **현상**: 몬스터 2,500마리의 위치 정보 패킷 크기는 약 **87,000 바이트**.
2.  **원인**: 패킷 헤더의 `size` 필드는 `uint16_t` (최대 65,535).
3.  **참사**: `87,000` -> `uint16_t` -> **`21,464`** (앞부분 절삭).
    *   메모리는 `21KB`만 할당했는데, 직렬화 함수(`SerializeToArray`)는 **87KB**를 덮어썼습니다.
    *   결과적으로 **66KB만큼 힙 메모리를 파괴(Heap Corruption)**했고, 운 좋게 10분을 버티다가 그 오염된 메모리를 건드리는 순간 사망했던 것입니다.

### 📝 배운 점 & 인사이트
*   **"자료형의 한계를 맹신하지 마라"**: `uint16_t`를 쓰면서 "설마 패킷 하나가 65KB를 넘겠어?"라고 방심했습니다. 하지만 MMO 환경에서 2,500마리는 충분히 가능한 숫자였습니다.
*   **"Silent Crash는 Heap Corruption을 의심하라"**: 로그 없이 죽는다면, 십중팔구 메모리 오염입니다.
*   **"테스트만이 살길이다"**: 막연한 추측(`NaN`?)보다는, 문제를 재현하는 **테스트 코드(`Reproduction Test`)** 하나가 백 배 더 강력했습니다.
