# 개발 일지 - 2025-12-20

## 요약
네트워크 시스템 계층 강화, 아키텍처 의존성 순환 문제 해결, 저수준 패킷 세부 정보 캡슐화에 집중했습니다. `PacketHeader`와 `PacketMessage`에 대한 주요 리팩토링이 수행되었습니다.

## 1. PacketHeader 아키텍처 리팩토링
**문제점:** `PacketHeader`가 `Share/Protocol.h`에 정의되어 있어, 핵심 `System` 계층이 애플리케이션 `Share` 계층에 의존하는 아키텍처 역전 현상이 발생했습니다. 또한 `VampireSurvivor`에서 구조체를 재정의하고 있어 프로토콜 불일치 위험이 있었습니다. 불완전한 타입에 대한 `sizeof` 사용으로 컴파일 오류도 발생했습니다.

**해결 방안:**
-   **System으로 이동**: `PacketHeader`를 `src/System/Packet/PacketHeader.h`로 이동하여 정의했습니다. 이를 통해 프레이밍(Framing) 및 라우팅(Routing)을 위한 핵심 시스템 계약(System Contract)으로 확립했습니다.
-   **견고한 정의**: 멤버 타입 별칭(`SizeType`, `IdType`)을 사용하여 구조체를 리팩토링하고, 이를 이용해 `SIZE`를 계산함으로써 불완전 타입 오류를 방지했습니다.
-   **사용 통합**:
    -   `Share/Protocol.h`에서 `System::PacketHeader`를 별칭(alias)으로 사용하도록 수정했습니다.
    -   `VampireSurvivor/Common/Protocol.h`에서 `System::PacketHeader`를 별칭으로 사용하도록 수정했습니다.
    -   중복 정의를 제거하여 '단일 진실 공급원(Single Source of Truth)' 원칙을 강제했습니다.
-   **검증**: 빌드 성공. `PacketHeader`가 제로 카피(Zero-Copy) 라우팅을 위한 "Envelope" 역할을 수행함을 검증했습니다.

## 2. Packet Message 캡슐화
**문제점:** `PacketMessage` 내부가 노출되어 있어 안전하지 않은 접근 패턴이 발생했습니다.
**해결 방안:**
-   `System/Network/PacketUtils.h`를 포워딩하는 `System/PacketUtils.h` (루트 레벨)를 생성했습니다.
-   `PacketMessage` 직접 접근을 더 안전한 유틸리티 함수 뒤로 캡슐화했습니다.
-   저수준 네트워킹 세부 정보가 로직 코드로 누수되는 것을 방지하도록 사용법을 업데이트했습니다.

## 3. Session 전송 로직 안정화
**문제점:** `Session::Send` 로직 및 큐 관리 관련 문제.
**해결 방안:**
-   스레드 안전성과 올바른 버퍼 관리를 보장하도록 `Send` 흐름을 개선했습니다.
-   (비동기 쓰기 중 올바른 `IncRef`/`DecRef` 보장 등).

## 4. 보류 / 다음 단계
-   `PacketHeader` 프레이밍의 효율성을 지속적으로 모니터링합니다.
-   새로운 통합 헤더 구조에서 `VampireSurvivor` 클라이언트 연결성을 검증합니다.

## 4. 고부하 CPU 점유율 디버깅 (High CPU Usage)
**문제점:** 서버 기동 직후 아무런 작업이 없는데도 CPU 100% 점유율이 발생하는 현상.
**원인:** Framework의 ThreadPool이나 Dispatcher가 작업이 없을 때 std::this_thread::yield()를 호출하며 공회전(Busy Wait)하도록 설계되어 있음. simple_game_config.json에서 task_worker_threads가 8로 설정되어, 사용하지 않는 8개의 스레드가 무한 루프를 돌며 CPU를 소모함.
**해결 방안:**
-   **Config 수정:** VampireSurvivor는 Task Thread를 사용하지 않으므로, simple_game_config.json에서 task_worker_threads를 0으로 설정하여 유휴 스레드 생성을 차단함.
-   **검증:** 설정 변경 후 CPU 점유율 정상화 확인.

## 5. Strand 패턴 구현 (Concurrency)
**목표:** 고성능 MMORPG를 위한 안전하고 확장 가능한 동시성 모델 구축. `ThreadPool`을 활용하되, 특정 엔티티(예: Room) 내의 작업은 순차성(Serialized)을 보장하여 Lock 경합 없이 안전하게 실행해야 함.

**구현 내용:**
-   **Strand 아키텍처:**
    -   `IStrand` 인터페이스 및 `Strand` 구현체 추가.
    -   기존 `ThreadPool`을 공유하여 사용. (별도의 스레드 생성 없음, Context Switch 최소화).
    -   `CreateStrand` 팩토리 메서드를 `IFramework`에 추가.
-   **VampireSurvivor 적용:**
    -   **Config:** `task_worker_threads`를 4로 설정하여 Worker Thread 활성화.
    -   **Room Loop:** `Room::Update`가 메인 스레드 타이머에서 직접 실행되는 대신, `Strand->Post`를 통해 Worker Thread로 던져져 병렬 처리됨.
    -   **Packet Handling:** `C_MOVE` 패킷 수신 시 `Room`의 Strand로 던져서 처리. 메인 스레드 부하 분산.
    -   **비고:** `IDispatcher` 상속 없이 가벼운 `Post(std::function)` 인터페이스로 구현하여 설계 단순화.

## [Critical Fix] Lobby Crash & Packet Broadcast Refactoring

### 1. Lobby Dangling Pointer Fix
**증상**: 클라이언트가 로비 입장 후 연결 종료 시, 또는 채팅 시도 시 서버 크래시 발생.
**원인**: `Dispatcher`가 세션 연결을 끊고 메모리를 해제했음에도, `RoomManager::_lobbySessions` 맵에는 해당 세션의 포인터(`ISession*`)가 남아있었음. 이후 브로드캐스트 시도 시 Dangling Pointer 접근으로 인한 Access Violation 발생.
**해결**:
*   `IPacketHandler` 인터페이스에 `OnSessionDisconnect(ISession* session)` 가상 함수 추가.
*   `GamePacketHandler`에서 이를 구현하여, 연결 종료 시 `RoomManager::LeaveLobby` 및 `UnregisterPlayer`를 호출하도록 함.
*   `DispatcherImpl::Process`에서 `NETWORK_DISCONNECT` 처리 시 핸들러의 `OnSessionDisconnect`를 명시적으로 호출.

### 2. Packet Broadcast Refactoring (Type Punning -> Single Ownership)
**증상**: `PacketBroadcast::Broadcast` 호출 중 `PacketStorage::Release`에서 크래시.
**분석**:
*   성능 최적화를 위해 `PacketBuilder`가 `PacketMessage`를 할당한 후 `PacketStorage`로 Type Punning(reinterpret_cast)하여 사용.
*   이 과정에서 `PacketStorage`의 멤버 변수들이 `PacketMessage`의 `vptr` 영역을 덮어씀.
*   `Release` 시 `MessagePool::Free`가 복귀하며 소멸자를 호출하려 할 때 오염된 `vptr`로 인해 크래시 발생.

**시도 및 결정 (Refactoring Journey)**:
1.  **시도 1 (FreeRaw)**: `MessagePool`에 소멸자를 부르지 않는 `FreeRaw` 추가. -> *기각 (임시 미봉책, 위험함)*
2.  **시도 2 (Inheritance)**: `PacketStorage`가 `IMessage`를 상속. -> *기각 (구조 복잡성)*
3.  **시도 3 (RefCounting)**: `PacketMessage`에 `refCount` 추가하여 Shared Ownership 시도. -> *기각 (Atomic False Sharing 및 성능 저하 우려)*
4.  **최종 해결 (Single Ownership & Copy)**:
    *   **Shared State 제거**: `refCount` 및 `PacketStorage` 클래스 완전 삭제.
    *   **Copy Strategy**: `Session::SendPreSerialized` 도입. 원본 메시지(Template)를 받아 **Memcpy**로 각 세션별 전용 사본을 생성하여 전송.
    *   **장점**: 멀티스레드 경합(Contention) 없음, False Sharing 방지, 메모리 수명 관리 명확화.

**결과**:
*   `PacketStorage` 관련 코드 삭제.
*   `Broadcast` 구현이 Safe-Copy 방식으로 변경됨.
*   서버 안정성 확보 및 고성능 원칙(Single Ownership) 준수.
