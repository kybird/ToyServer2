# 개발 일지 - 2025-12-21

## 요약
P2 단계의 핵심 목표인 **"대량 몬스터 스폰(Large Scale Monster Spawning)"** 및 동기화 최적화를 완료했습니다. 한 화면에 500+ 마리의 몬스터가 등장하는 상황을 가정하여, `SpatialGrid`를 도입하고 네트워크 프로토콜 및 동기화 로직을 대폭 개선했습니다. 성능 테스트 결과, 로직 처리 시간이 틱당 1ms 미만으로 측정되어 목표를 초과 달성했습니다.

## 1. Spatial Partitioning 도입 (AOI 기반)
**문제점:** 모든 객체 간의 거리를 계산하거나 `O(N^2)` 검사를 수행할 경우, 몬스터 수가 500+로 증가하면 성능 저하가 필연적입니다.

**해결 방안:**
- **Sparse Grid:** `SpatialGrid` 클래스를 구현하여, 맵을 격자(Cell)로 나누고 객체들을 관리했습니다.
- **Map Config:** Phase 1 데모(단일 화면) 요구사항에 맞춰 2000x2000 크기의 단일/소수 셀로 구성하여 **Full Broadcast** 구조를 유지하되, 향후 AOI 필터링이 가능하도록 기반을 마련했습니다.
- **검증:** `TestSpatialGrid.cpp` 유닛 테스트를 통해 삽입, 제거, 업데이트, 범위 검색 기능을 검증했습니다.

## 2. 대량 스폰 및 AI 최적화
**구현 내용:**
- **Batch Spawning:** `MonsterFactory::SpawnBatch`를 구현하여 루프 오버헤드를 줄이고 한 번에 다수의 몬스터를 생성 및 초기화하도록 했습니다.
- **Protocol Update:** `S_SpawnObject` (Repeated) 메시지를 통해 한 패킷에 여러 몬스터 정보를 담아 전송했습니다.
- **AI Load Balancing:** `ChaserAI` (Nearest Player 추적)의 `Think` 주기를 분산시키기 위해, 스폰 시 랜덤 위상(Phase Offset)을 부여하여 CPU 부하 스파이크를 방지했습니다.

## 3. 네트워크 동기화 최적화 (Network Optimization)
**목표:** 500마리의 몬스터가 10Hz로 움직일 때 발생하는 대역폭 폭증 제어.

**구현 내용:**
1.  **Protocol 개선:** `ObjectPos` 메시지에 `vx`, `vy` 필드를 추가하여 클라이언트 측 **Dead Reckoning(추측 항법)**을 지원했습니다.
2.  **Delta Sync:** 매 틱마다 무조건 전송하는 것이 아니라, 다음 조건에서만 패킷을 생성합니다.
    -   상태 변경 (Idle <-> Move)
    -   속도 벡터의 유의미한 변화 (Threshold > 0.01)
    -   마지막 전송 후 1초 경과 (Hard Sync for Drift Correction)
3.  **Packet Splitting:** `S_MoveObjectBatch` 패킷 생성 시, Protobuf 메시지 크기가 10KB(MTU 고려 안전치)를 초과하면 자동으로 패킷을 분할하여 전송하도록 로직을 구현했습니다.

## 4. 성능 검증 (Verification)
**테스트 환경:** `SwarmPerformanceTest` (GoogleTest)
-   **조건:** 몬스터 500마리 + 플레이어 1명 (AI 활성화 트리거)
-   **시나리오:** 1000 게임 틱(약 30초 분량) 수행

**결과:**
-   **Total Time:** < 10ms (1000 틱 합계)
-   **Per Tick:** < 0.01ms (순수 로직 처리)
-   **결론:** 서버 로직은 매우 가볍게 동작하며, 병목은 네트워크 I/O에서 발생할 가능성이 높음. 현재 최적화된 대역폭(약 160KB/s 예측)은 충분히 감당 가능한 수준임.

## 5. 기타 리팩토링
-   **CMakeLists.txt 수정:** `UnitTests` 타겟이 게임 로직 소스(`GAME_SOURCES`)를 공유하지 못해 발생하던 링킹 오류를 수정했습니다. 이제 유닛 테스트에서 `Room`, `Monster` 등 게임 핵심 클래스를 직접 테스트할 수 있습니다.

## 다음 단계
-   클라이언트(Unreal/Unity 등) 연동을 통한 실제 렌더링 및 동기화 부드러움 검증.
-   P3 단계(투사체, 웨이브 시스템) 구현 시작.
