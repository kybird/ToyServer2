# 2026-01-12 개발 로그: Ghost Hit과 네트워크 동기화의 비밀

## 🚀 기술 블로그 포스팅 초안

### 💡 오늘의 도전: "왜 안 닿았는데 맞는가?" (The Mystery of Ghost Hits)
오늘의 가장 큰 난관은 **"Ghost Hit"** 현상이었습니다. 클라이언트 화면상으로는 몬스터가 아직 캐릭터에 닿지 않았는데, 데미지를 입는 **불합리한 피격 판정**이 발생했습니다.
처음에는 단순한 동기화 오차라고 생각했지만, 분석 결과 **네트워크 지연(Latency)과 물리 판정의 괴리**가 주범이었습니다.

### 🛠 해결 과정: 공학적 접근

#### 1. 랙 보정(Lag Compensation)을 위한 판정 범위 최적화
서버와 클라이언트의 `Radius`가 모두 `0.5`로 동일했습니다. 하지만 클라이언트의 몬스터는 **과거(RTT/2 전)**의 위치를 렌더링하고 있습니다.
서버의 몬스터는 이미 내 몸에 도달했지만, 내 눈에는 아직 멀리 있는 것이죠.

이를 해결하기 위해 **"상대성"**을 도입했습니다.
- **Visual Size**: 1.0 (Radius 0.5) - 유지
- **Physical Radius (Server)**: 0.5 -> **0.2** - 축소

```cpp
// Server/Entity/Monster.h
void Initialize(...) {
    // ...
    _radius = 0.2f; // Lag Compensation: Visual(0.5) - BufferDelay
}
```
서버의 판정 범위를 60% 줄임으로써, **"시각적으로 겹쳐야만(Overlapping)"** 물리적으로 충돌하도록 만들었습니다. 이 **여유 마진(Safety Margin)**이 네트워크 지연을 상쇄시켰습니다.

#### 2. 데드레코닝(DeadReckoning) 단위 변환 오류 수정
몬스터가 너무 빨리 움직이는 문제도 있었습니다.
- **Server**: 초당 속도 (`units/second`) 전송
- **Client**: 틱당 속도 (`units/tick`)로 해석

이로 인해 클라이언트 몬스터가 25배(TickRate) 빠르게 이동하여 위치 불일치를 가중시켰습니다.
```csharp
// DeadReckoning.cs
// 속도 단위 정규화: (Units/Sec) / TickRate = (Units/Tick)
vel = new Vector2(vx, vy) / TickManager.Instance.TickRate;
```
받은 속도를 `TickRate`로 나누어 정상 속도를 찾았습니다.

#### 3. 스폰 레이스 컨디션(Race Condition) 제어
로딩이 끝나기도 전에 게임 준비 패킷(`C_GameReady`)을 보내, 서버의 스폰 패킷(`S_SpawnObject`)이 씹히는 문제가 있었습니다.
**코루틴(Coroutine)**을 사용하여 상태가 확실히 `InGame`이 될 때까지 기다린 후 패킷을 보내도록 수정했습니다.

### 📝 배운 점 & 인사이트
1.  **"보이는 것이 전부는 아니다"**: 네트워크 게임에서 '보이는 크기'와 '맞는 크기'는 달라야 합니다. 특히 P2P가 아닌 권한 서버(Authoritative Server) 구조에서는 **랙 보정 마진**이 필수적입니다.
2.  **단위(Unit)의 중요성**: 시간(`Time.deltaTime`)과 틱(`Tick`)은 전혀 다른 차원입니다. 데이터 전송 시 단위를 명확히 규약(Protocol)화 해야 합니다.
3.  **상태 기계(State Machine)의 엄격함**: 네트워크 패킷은 비동기적이므로, 클라이언트 상태가 완벽히 준비된 후 통신을 시작해야 안전합니다.

---
*오늘의 팁: 억울한 판정은 유저를 떠나게 한다. 때로는 수학적 정확함보다 "납득 가능한 감각"이 더 중요하다.*
