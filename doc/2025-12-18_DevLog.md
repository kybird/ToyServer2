# 2025-12-18 개발 일지 (DevLog) - 통합본

## 금일 작업 요약 (Overall Work Summary)

오늘 하루 동안 총 3단계의 주요 작업이 진행되었습니다.

### 1. 로비 시스템 구현 (Lobby System Implementation)
- **목표**: 방 생성, 입장, 리스트 조회 등 로비 기본 기능 구현
- **작업 내용**:
    - `RoomManager` 확장: 로비와 개별 게임 룸 관리 로직 분리 및 통합
    - **Protocol 정의**: `C_CreateRoom`, `C_JoinRoom`, `C_EnterLobby` 등 네트워크 패킷 정의 및 Protobuf 컴파일
    - **핸들러 구현**: 클라이언트 요청에 따라 방을 생성하고 유저를 이동시키는 패킷 핸들러 구현 완료
    - **테스트**: 더미 클라이언트를 사용하여 로비 입장 및 방 생성/입장 플로우 검증

### 2. 패킷 핸들링 리팩토링 및 보안 강화 (Packet Refactoring & Security)
- **목표**: 보안성과 성능 개선을 위한 패킷 처리 구조 개편
- **작업 내용**:
    - **암호화 도입**: XOR 및 AES 암호화 알고리즘 구현 (외부 라이브러리 최소화)
    - **PacketView 도입**: 기존의 단순 버퍼 포인터 접근 방식을 `PacketView` 클래스로 캡슐화하여 데이터 접근 안전성 확보
    - **설정 파일 통합**: `server_config.json`을 통해 암호화 여부 및 키 설정을 제어하도록 변경
    - **Session 계층 통합**: `Session` 클래스에서 패킷 수신 시 "Decrypt-on-Copy" 전략 적용

### 3. 데이터베이스 연동 및 크래시 해결 (DB Integration & Debugging)
- **목표**: `Vampire Survivor` 예제 프로젝트에 DB 지속성(Persistence) 연동
- **트러블슈팅 (Critical Fix)**:
    - **현상**: 로그인 시도 시 `SQLiteConnection` 관련 "Internal driver exception" 및 서버 크래시 발생
    - **원인 (Root Cause)**:
        - `IConnection` 인터페이스는 `enable_shared_from_this`를 상속받지 않았으나, 구현체인 `SQLiteConnection`만 상속받음.
        - `DatabaseImpl`에서 `IConnection*` (업캐스팅된 포인터)로 관리되는 객체에서 `shared_from_this()` 호출 시 `bad_weak_ptr` 발생.
        - 또한 `DatabaseImpl::Query`가 커넥션의 수명(Lease)을 결과 셋(`ResultSet`)의 수명보다 짧게 관리하여, 결과 조회 중 커넥션이 풀로 반환되는 경쟁 상태(Race Condition) 존재.
    - **해결 (Solution)**:
        - `ResultSetWrapper` 도입: 결과 셋이 살아있는 동안 커넥션의 `shared_ptr`를 붙잡고 있도록 수명 연장.
        - **Raw Pointer 전환**: 내부 구현(`SQLiteResultSet` 등)에서 `shared_ptr` 의존성을 제거하고 Raw Pointer를 사용하여 `shared_from_this` 문제 원천 차단.

---

## 기술적 교훈 및 향후 대책 (Technical Lessons & Prevention)

### Shared Ptr & Inheritance Mismatch
- **문제점**: 인터페이스(`IConnection`)와 구현체(`SQLiteConnection`) 간의 `enable_shared_from_this` 상속 불일치는 `shared_ptr` 제어 블록 공유 실패를 야기합니다.
- **예방책**:
    - 리소스 풀링(Pooling)을 사용하는 객체 내부에서는 가급적 `shared_from_this()` 사용을 지양합니다.
    - 수명 관리는 외부 매니저(`DatabaseImpl` 등)에게 위임하고, 내부 객체는 **Handle**이나 **Raw Pointer**로 동작하도록 설계하여 복잡도를 낮춰야 합니다.

### RAII 기반 리소스 관리
- `DatabaseImpl`과 같이 리소스를 대여(Acquire)해주는 시스템에서는, 사용자가 직접 `Release`를 호출하게 하거나 포인터만 던져주기보다, `ScopedGuard`나 `Wrapper`를 통해 스코프를 벗어나면 자동으로 반환되거나 수명이 유지되도록 강제하는 것이 안전합니다. 오늘의 `ResultSetWrapper`가 그 모범 사례가 되었습니다.
