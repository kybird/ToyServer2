프로젝트: Custom Server Framework 기반 뱀파이어 서바이버 (Final Spec)1. 프로젝트 개요목표: 자체 제작 서버 프레임워크의 성능(Throughput)과 안정성을 입증하기 위한 포트폴리오용 게임 서버 개발.타겟 클라이언트: Unity (클라이언트 개발은 별도로 진행하나, 통신 규격은 서버 주도로 정의).핵심 컨셉: "Co-op Swarm Survival" - 협동 플레이를 중심으로, 단일 화면 내에 수백 개의 객체와 유저 간 상호작용을 동기화.기술적 검증 포인트: * Protobuf 기반의 효율적인 직렬화/역직렬화.대량 객체(Massive Entities)의 위치 동기화 시 대역폭 절감 기법.유저 간 상호작용(부활, 힐링, 어그로) 및 상태 동기화 (State Synchronization).데이터 주도(Data-Driven) 웨이브 및 스킬 조합/진화 시스템.DB 연동을 통한 영구적 성장(Meta-Progression) 데이터 관리.2. 시스템 아키텍처 (Server Authoritative)서버 모델: * Single-Threaded Event Loop 또는 Multi-Threaded Worker (프레임워크 특성에 맞게 선택).권장 Tick Rate: 15~20 FPS (대량 유닛 동기화를 위해 Tick을 낮추고 클라이언트 보간에 의존하는 전략 고려).월드 관리 (Room-Based):RoomManager: 클라이언트의 C_CreateRoom 요청 시 방 생성, C_JoinRoom 시 입장 처리.방 생성 옵션: 방 생성 시 WavePatternID를 지정하거나 랜덤 선택 (예: 1=언데드 군단, 2=식물원 등).Lifecycle: 대기실(Lobby) -> 클래스 선택 -> 게임 시작 -> 5분 생존(웨이브 클리어) 또는 전멸 -> 결과창 -> 방 삭제 또는 초기화.Grid 기반 Spatial Partitioning: 수천 개의 유닛 간 충돌 감지 및 AOI(Area of Interest) 처리를 위해 필수.데이터베이스 (Persistence Layer):역할: 유저의 계정 정보, 재화(Gold/Points), 해금된 스킬 트리 정보 저장.타이밍: 로그인 시 로드(Select), 게임 종료 시 결과 저장(Update/Insert).3. 통신 프로토콜 (Google Protobuf)직렬화: Google Protocol Buffers (v3) 사용.패킷 구조: * PacketHeader (Size + ID) + Protobuf Payload.proto 설계 전략 (대역폭 최적화):Batching 필수: 몬스터 1마리당 패킷 1개가 아니라, MonsterUpdateList 메시지 하나에 수백 마리의 정보를 담아 전송.데이터 최적화: * 위치 좌표는 float 대신 맵 좌표를 정수화(int32 또는 short)하여 전송 고려.repeated 필드를 적극 활용하여 구조체 오버헤드 감소.4. 구현 기능 명세 (MVP - Server Side)A. 접속 및 세션 관리로그인 정책 (Auto-Registration):별도의 회원가입 절차 생략. 아이디/비번 입력 시 자동 생성/로그인.네트워크:Unity 클라이언트와의 TCP/IP 연결 수립.플레이어 입장/퇴장 브로드캐스팅.B. 채팅 시스템 (Communication)구조: ChatManager를 통해 메시지 라우팅.월드 채팅 (Lobby):대기실(Lobby) 상태에 있는 모든 유저에게 메시지 브로드캐스팅.게임 중인 유저에게는 전달되지 않음 (트래픽 분리).룸 채팅 (In-Game):특정 GameRoom 내의 플레이어(최대 4명)끼리만 대화.전략적 소통(부활 요청, 스킬 쿨타임 공유 등) 용도.C. 아웃게임 성장 (Meta-Progression)영구적 성장 시스템 (Out-game Skill Tree):개념: 인게임에서 레벨업하며 얻은 스킬은 게임 종료 시 초기화되지만, 획득한 **'성장 포인트(Growth Point)'**는 영구 보존됨.스킬 트리: 로비(Lobby)에서 포인트를 소모하여 영구 능력치 강화.예: MaxHP +10%, MoveSpeed +5%, StartWeapon: Axe.DB 연동: C_UpgradeSkillNode 요청 시 DB 트랜잭션을 통해 포인트 차감 및 노드 해금 처리.인게임 적용:게임 시작(EnterGame) 시, 서버는 해당 유저의 Unlocked Nodes 정보를 DB에서 조회.Player 객체 생성 시 기본 스탯(Base Stats)에 영구 강화 수치를 합산하여 초기화.D. 인게임 로직 (Co-op PVE)캐릭터 클래스 및 고유 스킬 (Class System):구조: 게임 시작 전(Lobby) 유저는 클래스를 선택(C_SelectClass).1. 나이트 (Knight - Tanker):특성: 높은 체력, 넉백 저항.고유 스킬 (Taunt): [Active] 주변 10m 내 몬스터의 Target을 강제로 자신으로 변경. (구현 난이도: 하 / 효과: 상)2. 메이지 (Mage - Nuker):특성: 높은 공격력, 낮은 체력.고유 스킬 (Meteor): [Active] 지정 범위에 3초 후 폭발 데미지. (서버 타이머/범위 체크 로직)3. 프리스트 (Priest - Healer):특성: 아군 회복.고유 스킬 (Sanctuary): [Active] 장판 생성. 위 아군 HP 회복 및 부활 가속. (틱 단위 힐링 로직)동기화 (Core):시나리오: 한 화면에 500+ 마리의 적이 등장.이동 동기화: 서버 Tick마다 위치 계산 -> S_MoveObjectBatch 패킷 전송.최적화: Delta Compression 및 LOD 적용.게임 세션 규칙 (5분 웨이브 디펜스):승리 조건: 5분 동안 전멸하지 않고 모든 웨이브 패턴 생존 시 승리 (S_GameWin).패배 조건 (Game Over): 방에 있는 모든 플레이어가 DOWNED(빈사) 상태가 되면 즉시 패배 (S_GameOver).보상 처리:승리/패배 시 생존 시간과 처치 수에 비례하여 성장 포인트 지급 및 DB 저장.웨이브 시스템 (Structured Waves):단순 랜덤 스폰이 아닌, 시간대별 정의된 패턴에 따라 몬스터 생성.난이도 자동 조절 (Dynamic Difficulty):유저 수(N) 기반 스케일링: 방에 입장한 유저 수에 따라 몬스터의 능력치를 보정.스킬 및 성장 시스템 (In-Game Progression):스킬 구분: Active(Weapon) / Passive(Item).레벨업 로직 (3-Choice RNG):서버가 S_LevelUpOption (3개) 전송 -> 클라가 키보드 1, 2, 3으로 선택 (C_SelectLevelUp) -> 서버 적용.진화 시스템 (Evolution Logic):조건: Weapon Max Level + Passive Item + Box.효과: 객체 교체 (Hot-Swap).스킬 시스템 (Server-Authoritative):Auto-Combat: 서버가 쿨타임 관리 및 자동 발사.Ultimate Skill: 유저 입력 시 클래스 고유 스킬 발동.사망 및 부활 시스템 (Revive Mechanic):Downed State: HP 0 -> DOWNED (묘비).Revive: 동료가 근처(2m)에서 3초 유지 시 부활.아이템 드랍 (Drop System):Exp Gem: 병합(Merge) 로직 필수.Potion: 위기 탈출용 회복 아이템.5. 코딩 에이전트 작업 지시 사항 (Server Only)1단계: 프로토콜 정의 (.proto)로그인, 이동, 스폰, 배치 업데이트.채팅: C_Chat (Message), S_Chat.전투: S_SpawnProjectile, S_EnemyHit, C_UseUltimate, S_UltimateEffect.클래스: C_SelectClass (int32 classId), S_ClassChange.성장: S_LevelUpOption (Active/Passive 구분), C_SelectLevelUp, S_EvolutionEffect.상호작용: S_PlayerDowned, S_PlayerRevive, S_ReviveProgress.아웃게임: S_SkillTreeInfo, C_UpgradeSkillNode.방 생성: C_CreateRoom.게임 결과: S_GameWin, S_GameOver.2단계: 객체 및 월드 관리자 구현 (Scalable Architecture)Data-Driven Monster & Skill Design (확장성 설계):MonsterData, SkillTemplate 등 정적 데이터와 Monster, SkillInstance 등 동적 객체 분리.Factory 패턴을 사용하여 데이터 기반 객체 생성.DB Integration (Persistence):DBManager: 유저의 포인트 및 스킬 트리 정보를 로드/저장하는 인터페이스 구현 (Mock DB 또는 SQLite/MySQL 연동).Player: 생성 시 DBManager에서 가져온 영구 스탯을 기본값에 적용하는 로직 추가.Wave System (Spawn Manager):WaveDataTable: JSON 등에서 로드한 웨이브 정보.Room: Update()에서 CurrentTime을 체크하며, 정의된 시간에 도달하면 MonsterFactory를 통해 몬스터 대량 생성.Room: 유저들의 생존 여부를 매 틱 체크하여 게임 오버 판정 로직 추가.Spatial Grid: 유저 간 거리 계산(부활 판정) 최적화.3단계: 게임 루프 및 패킷 처리메인 Game Loop 구현 (Update -> Physics -> Logic(Revive Check) -> Broadcast).채팅 처리: ChatManager 구현.Protobuf 메시지 처리를 위한 패킷 핸들러 스켈레톤 코드.6. 포트폴리오 강조 포인트Full-Stack 역량: 실시간 게임 서버(Socket)와 영구 데이터 관리(DB)의 연동 구조 설계.상태 동기화: Downed -> Reviving -> Alive 상태 변화 제어.협동 시너지 구현: 탱커/딜러/힐러 역할 분담 로직.확장성: 데이터 주도(Data-Driven) 설계.복합 조건 로직: 조합/진화 시스템 구현.7. 개발 로드맵 (Priority)P1 (엔진 검증): 접속, 500마리 스폰, 이동 동기화.P2 (게임 루프): 투사체, 웨이브, 게임 오버.P3 (콘텐츠 확장): 클래스 3종 & 고유기, 부활, 진화.P4 (완성도): DB 연동, 채팅.8. 데이터 스키마 예시 (JSON Templates)A. MonsterData.json[
  { "id": 1, "name": "Zombie", "hp": 100, "ai_type": "CHASER" },
  { "id": 2, "name": "Bat", "hp": 50, "ai_type": "SWARM" }
]
B. ClassData.json (New!)[
  {
    "id": 1,
    "name": "Knight",
    "base_hp": 200,
    "ultimate_skill_id": 9001 // Taunt
  },
  {
    "id": 2,
    "name": "Mage",
    "base_hp": 80,
    "ultimate_skill_id": 9002 // Meteor
  }
]
C. EvolutionData.json[
  { "base_weapon_id": 201, "required_passive_id": 301, "evolved_weapon_id": 401 }
]
D. SkillTreeData.json[
  { "node_id": 101, "effect_type": "MAX_HP", "value": 10.0, "cost": 100, "parent_id": 0 }
]
