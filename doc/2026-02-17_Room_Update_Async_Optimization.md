# 룸 업데이트 비동기 최적화 및 메인 스레드 병목 해결 (2026-02-17)

## 1. 개요
스트레스 테스트(3,000 CCU) 환경에서 클라이언트가 모두 종료되었음에도 불구하고 서버의 CPU 점유율이 즉각적으로 떨어지지 않고, 서버 종료(Shutdown) 시 수 분 이상의 지연이 발생하는 현상을 해결하기 위한 아키텍처 최적화 작업입니다.

## 2. 문제 분석 (Diagnosis)
### 2.1. 로직 스레드 병목 (Dispatcher Thread Choke)
- **증상**: 서버가 클라이언트의 접속 종료(`NETWORK_DISCONNECT`)를 제때 처리하지 못하고 수십 초~수 분 뒤에 처리함.
- **원인**: 타이머에 의해 호출되는 `Room::Update` 로직(수천 마리 몬스터의 AI 및 물리 연산)이 Dispatcher의 로직 스레드에서 직접 실행됨. 로직 스레드가 연산에 갇혀 메시지 큐를 읽지 못하는 "수신 거부" 상태 발생.

### 2.2. 작업 누적 (Task Piling & Backlog)
- **증상**: 서버 셧다운 시 `ThreadPool`이 종료되지 않고 11분 이상 대기함.
- **원인**: 로직 스레드가 한 프레임을 처리하는 동안 타이머는 계속해서 새로운 "업데이트 메시지"를 큐에 쌓음. 처리 속도보다 유입 속도가 빨라 큐가 무한히 늘어나는 좀비 태스크 현상 발생.

### 2.3. 타이머 경로 미처리 (Timer Path Not Serialized)
- **증상**: 간헐적인 크래쉬 가능성.
- **원인**: 2/16 작업에서 `Enter`, `Leave` 등은 이미 `Strand`로 직렬화되었으나, **타이머 콜백(`OnTimer`)만 여전히 로직 스레드에서 직접 실행**되어 `_players` 맵 등 공유 자원에 동시 접근 가능성 존재.

## 3. 해결 방안 (Implementation)
### 3.1. 타이머 경로 Strand 이관 (Timer Path Offloading)
- 2/16 작업에서 도입된 룸 전용 `Strand`를 **타이머 콜백까지 확장**하여 `OnTimer`도 `_strand->Post()`로 게시.
- 로직 스레드는 즉시 해방되어 시스템 메시지 및 네트워킹 처리에 집중 가능.

### 3.2. 원자적 프레임 스킵 (Atomic Frame Skipping)
- `_isUpdating` 원자적 플래그(`std::atomic<bool>`) 도입.
- **메커니즘**: `OnTimer` 호출 시 이전에 게시된 업데이트가 아직 완료되지 않았거나 대기 중이라면, 새로운 업데이트 작업을 생성하지 않고 건너뜀(Skip).
- 이를 통해 부하 상황에서도 작업 큐가 폭주하는 것을 원천 차단.

### 3.3. 룸 로직 완전 일원화 (Complete Serialization)
- 2/16 작업에서 도입된 Strand 직렬화를 **타이머 경로까지 확장**하여 입장(`Enter`), 퇴장(`Leave`), 업데이트(`Update`), 패킷 핸들링을 모두 **동일한 단일 Strand**에서 실행.
- 룸 내부 데이터에 대한 100% 직렬화 보장으로 데이터 레이스 제거.

## 4. 결과 및 기대 효과 (이번 작업 고유 기여)
- **반응성 개선**: 클라이언트 접속 종료 즉시 서버 부하가 하락(좀비 시뮬레이션 중단).
- **프레임 스킵**: `_isUpdating` CAS 플래그로 작업 누적 방지, 셧다운 시 즉각 종료.
- **타이머 직렬화 완성**: 2/16 Strand 도입의 마지막 퍼즐 조각(타이머 경로) 완성으로 100% 직렬화 달성.

## 5. 향후 과제
- 프레임 스킵 발생 시 클라이언트에게 보정 정보를 전달하는 타임 드리프트 관리 로직 검토.
- 고부하 환경에서 프레임 스킵 빈도 모니터링 및 로그 추가.
